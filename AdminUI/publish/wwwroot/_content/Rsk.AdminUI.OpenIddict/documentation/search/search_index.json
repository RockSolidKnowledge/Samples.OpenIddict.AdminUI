{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"This documentation will clearly show you how to undertake all OpenIddict configuration tasks: Including authorizing new client applications by application type Including authorizing new API applications Configure scopes Manage users and assigning them identity roles and identity claims. After reading these documents, you will also understand how to deploy the AdminUI for OpenIddict using the NuGet package As of 6.3 AdminUI is a single site hosting both the SPA and API For additional support email support@openiddictcomponents.com","title":"About"},{"location":"Access_Policy/Access_Policy.html","text":"TODO Update, will be in setting for V1 probably Introduction Access Policy maps claim values to permissions, each time a user attempts to perform some administrator functionality their claims are evaluated against the policy to produce a set of permissions. Only if they have the appropriate permission will they be able to execute the functionality. Managing Your Access Policy In order to manage your access policy, you will need to have the \u2018All\u2019 permission. Access Policy Management is available in the Settings tab, new policies can be added and removed here. After making any changes you will need to save your changes in order for them to take effect. To make use of this new policy, you will need to give this new claim to a user. Users can get permissions from multiple access policy statements. Only users with the \u2018All\u2019 permission are able to assign claims referenced in the access policy to themselves or other users. Warning: any user that already has the claim in the access policy you are adding will be given the permission. This is also true if an access policy is removed, where any users with that claim will lose that permission. Permissions Users without any permissions will be greeted with an unauthorized screen after logging in. There are three read/write permissions available, each giving access to different actions within AdminUI: User Manager This permission grants control over User and Role management Identity Server Manager This permission allows users to create and modify ClaimTypes, Clients, Identity Resources, and Protected Resources All This permission allows all of the above and control over Access Policy Management As of AdminUI 5.5.0/4.6.0 there are 3 read only permissions available: User Manager Read Only This permission a user the ability to view Users and Roles Identity Server Manager Read Only This permission allows to view ClaimTypes, Clients, Identity Resources, and Protected Resources All Read Only This permission combines the two read only permissions above By default, the 'AdminUI Administrator' role is set up by default with the All permission. This mapping cannot be removed. Access Policies and External User Stores If you are using an external user store (e.g. AzureAD) you may need to create access policies based on known claim types for your users. For example, you may want to create an access policy based on an external user's email claim type. To do this, navigate to the Access Policy view and click the 'Add Policy' button. Next, choose the claim type you wish to create the access policy against (in our case the email claim type), as well as the claim value you expect to satisfy the policy. Lastly, choose the AdminUI permission you wish to grant users who satisfy these conditions. Adding an Access Policy to a Client or User After creating your Access Policy as described in the Managing Your Access Policy section above you can add it to your client by clicking the 'Add Claim' button. You will be greeted with a modal that requires you to enter the 'Type' and 'Value' of the Claim you are wishing to add. These values correspond to the Claim Type and Claim Value of the access policy you have created. For example, if you are adding a client that requires the AdminUI Administrator Access Policy as shown below: You should be entering the Claim Type 'role' and the Claim Value 'AdminUI Administrator' into the 'Add Claim' modal in the edit client view as shown below. After saving these changes, your client should be able to interact with the AdminUI API correctly. Viewing Client Access Policies From the Clients page, click the edit client button then navigate to the 'Advanced' tab, then click the 'Claims' button. Here you can see the various Claims assigned to a client and is where you add your Access Policies to your clients.","title":"Access Policy"},{"location":"Access_Policy/Access_Policy.html#todo-update-will-be-in-setting-for-v1-probably","text":"","title":"TODO Update, will be in setting for V1 probably"},{"location":"Access_Policy/Access_Policy.html#introduction","text":"Access Policy maps claim values to permissions, each time a user attempts to perform some administrator functionality their claims are evaluated against the policy to produce a set of permissions. Only if they have the appropriate permission will they be able to execute the functionality.","title":"Introduction"},{"location":"Access_Policy/Access_Policy.html#managing-your-access-policy","text":"In order to manage your access policy, you will need to have the \u2018All\u2019 permission. Access Policy Management is available in the Settings tab, new policies can be added and removed here. After making any changes you will need to save your changes in order for them to take effect. To make use of this new policy, you will need to give this new claim to a user. Users can get permissions from multiple access policy statements. Only users with the \u2018All\u2019 permission are able to assign claims referenced in the access policy to themselves or other users. Warning: any user that already has the claim in the access policy you are adding will be given the permission. This is also true if an access policy is removed, where any users with that claim will lose that permission.","title":"Managing Your Access Policy"},{"location":"Access_Policy/Access_Policy.html#permissions","text":"Users without any permissions will be greeted with an unauthorized screen after logging in. There are three read/write permissions available, each giving access to different actions within AdminUI: User Manager This permission grants control over User and Role management Identity Server Manager This permission allows users to create and modify ClaimTypes, Clients, Identity Resources, and Protected Resources All This permission allows all of the above and control over Access Policy Management As of AdminUI 5.5.0/4.6.0 there are 3 read only permissions available: User Manager Read Only This permission a user the ability to view Users and Roles Identity Server Manager Read Only This permission allows to view ClaimTypes, Clients, Identity Resources, and Protected Resources All Read Only This permission combines the two read only permissions above By default, the 'AdminUI Administrator' role is set up by default with the All permission. This mapping cannot be removed.","title":"Permissions"},{"location":"Access_Policy/Access_Policy.html#access-policies-and-external-user-stores","text":"If you are using an external user store (e.g. AzureAD) you may need to create access policies based on known claim types for your users. For example, you may want to create an access policy based on an external user's email claim type. To do this, navigate to the Access Policy view and click the 'Add Policy' button. Next, choose the claim type you wish to create the access policy against (in our case the email claim type), as well as the claim value you expect to satisfy the policy. Lastly, choose the AdminUI permission you wish to grant users who satisfy these conditions.","title":"Access Policies and External User Stores"},{"location":"Access_Policy/Access_Policy.html#adding-an-access-policy-to-a-client-or-user","text":"After creating your Access Policy as described in the Managing Your Access Policy section above you can add it to your client by clicking the 'Add Claim' button. You will be greeted with a modal that requires you to enter the 'Type' and 'Value' of the Claim you are wishing to add. These values correspond to the Claim Type and Claim Value of the access policy you have created. For example, if you are adding a client that requires the AdminUI Administrator Access Policy as shown below: You should be entering the Claim Type 'role' and the Claim Value 'AdminUI Administrator' into the 'Add Claim' modal in the edit client view as shown below. After saving these changes, your client should be able to interact with the AdminUI API correctly.","title":"Adding an Access Policy to a Client or User"},{"location":"Access_Policy/Access_Policy.html#viewing-client-access-policies","text":"From the Clients page, click the edit client button then navigate to the 'Advanced' tab, then click the 'Claims' button. Here you can see the various Claims assigned to a client and is where you add your Access Policies to your clients.","title":"Viewing Client Access Policies"},{"location":"ApplicationApis/Adding_API.html","text":"TODO Create","title":"Creating APIs"},{"location":"ApplicationApis/Adding_API.html#todo-create","text":"","title":"TODO Create"},{"location":"ApplicationApis/Clone_a_API.html","text":"TODO Create","title":"Clone APIs"},{"location":"ApplicationApis/Clone_a_API.html#todo-create","text":"","title":"TODO Create"},{"location":"ApplicationApis/Deleting_API.html","text":"TODO Create","title":"Delete APIs"},{"location":"ApplicationApis/Deleting_API.html#todo-create","text":"","title":"TODO Create"},{"location":"ApplicationApis/Editing_API.html","text":"TODO Create","title":"Edit APIs"},{"location":"ApplicationApis/Editing_API.html#todo-create","text":"","title":"TODO Create"},{"location":"ApplicationApis/Searching_for_API.html","text":"TODO Create","title":"Srarching for APIs"},{"location":"ApplicationApis/Searching_for_API.html#todo-create","text":"","title":"TODO Create"},{"location":"ApplicationClients/Adding_Clients.html","text":"TODO Create","title":"Creating Clients"},{"location":"ApplicationClients/Adding_Clients.html#todo-create","text":"","title":"TODO Create"},{"location":"ApplicationClients/Clone_a_client.html","text":"TODO Create","title":"Clone Clients"},{"location":"ApplicationClients/Clone_a_client.html#todo-create","text":"","title":"TODO Create"},{"location":"ApplicationClients/Deleting_clients.html","text":"TODO Create","title":"Delete Clients"},{"location":"ApplicationClients/Deleting_clients.html#todo-create","text":"","title":"TODO Create"},{"location":"ApplicationClients/Editing_clients.html","text":"TODO Create","title":"Edit Clients"},{"location":"ApplicationClients/Editing_clients.html#todo-create","text":"","title":"TODO Create"},{"location":"ApplicationClients/Searching_for_clients.html","text":"TODO Create","title":"Srarching for Clients"},{"location":"ApplicationClients/Searching_for_clients.html#todo-create","text":"","title":"TODO Create"},{"location":"Audit/Auditing.html","text":"TODO Modify for OpenIddict once supported, not in V1 Auditing within AdminUI Audit records can either be viewed through the main navigation bar option Auditing, or through the Auditing tab on a User or Resource. On these pages you can: Filter audit records Time based Source, Origin of the audit event Action, the action of the event Resource, the entity the action was applied to Source, the entity performing the action Download audit records in CSV format To view audit records you need to either have the Auditing permission or All permission. Auditing Configuration The following configuration settings can be used to control Auditing within AdminUI AuditRecordsConnectionString The database connection string for AdminUI audits, if missing will default to the IdentityServerConnectionString AuditRecordsCulture Language used for generation of audit records, if missing or invalid will default to English (en-GB), supported cultures and their values are: de German zh-TW Chinese (Traditional) zh-CN Chinese (Simplified) es Spanish fr French AuditReadActions Set to true or false , if missing will default to true , if false no audit records will be generated for read actions e.g when a user views resources though AdminUI IdentityServer Auditing Events that happen inside IdentityServer can be recorded into the same audit database as AdminUI, providing a single view of all Identity related events. To learn how to integrate your IdentityServer auditing into AdminUI, follow our walkthrough here Resource Specific Audit Tab When navigating to Users and Clients there is a resource specific audit tab where you can access logs related to the User or Client you are viewing or editing. On this screen an option is added to the filters named 'When Subject or Resource'. This will get audits where the current entity being viewed is the Subject(actor making the action) when Subject is selected and the Resource(target of any action being made) when Resource is selected.","title":"Auditing"},{"location":"Audit/Auditing.html#todo-modify-for-openiddict-once-supported-not-in-v1","text":"","title":"TODO Modify for OpenIddict once supported, not in V1"},{"location":"Audit/Auditing.html#auditing-within-adminui","text":"Audit records can either be viewed through the main navigation bar option Auditing, or through the Auditing tab on a User or Resource. On these pages you can: Filter audit records Time based Source, Origin of the audit event Action, the action of the event Resource, the entity the action was applied to Source, the entity performing the action Download audit records in CSV format To view audit records you need to either have the Auditing permission or All permission.","title":"Auditing within AdminUI"},{"location":"Audit/Auditing.html#auditing-configuration","text":"The following configuration settings can be used to control Auditing within AdminUI AuditRecordsConnectionString The database connection string for AdminUI audits, if missing will default to the IdentityServerConnectionString AuditRecordsCulture Language used for generation of audit records, if missing or invalid will default to English (en-GB), supported cultures and their values are: de German zh-TW Chinese (Traditional) zh-CN Chinese (Simplified) es Spanish fr French AuditReadActions Set to true or false , if missing will default to true , if false no audit records will be generated for read actions e.g when a user views resources though AdminUI","title":"Auditing Configuration"},{"location":"Audit/Auditing.html#identityserver-auditing","text":"Events that happen inside IdentityServer can be recorded into the same audit database as AdminUI, providing a single view of all Identity related events. To learn how to integrate your IdentityServer auditing into AdminUI, follow our walkthrough here","title":"IdentityServer Auditing"},{"location":"Audit/Auditing.html#resource-specific-audit-tab","text":"When navigating to Users and Clients there is a resource specific audit tab where you can access logs related to the User or Client you are viewing or editing. On this screen an option is added to the filters named 'When Subject or Resource'. This will get audits where the current entity being viewed is the Subject(actor making the action) when Subject is selected and the Resource(target of any action being made) when Resource is selected.","title":"Resource Specific Audit Tab"},{"location":"Bootstrapping/Bootstrapping_Help.html","text":"Bootstrapping AdminUI For AdminUI to work out of the box, it has some behaviour turned on by default that inserts the required data into the OpenIddict, and Identity database tables on the app start if missing. If the user table is empty, this also inserts a default user into the database on the first start-up. Disabling Bootstrapping You can disable this functionality in the app's configuration. Help for configuring AdminUI can be found here. The bootstrapping in AdminUI is not concurrency safe, so if you were to have multiple instances of AdminUI running, you would need to disable bootstrapping to avoid running into errors when trying to start AdminUI for the first time. Running Manually If you disable Bootstrapping, we have added the ability to run it manually using the AdminUI binaries via the command line, which can also be done for migrations. You can do this by navigating to your AdminUI install directory and locating the IdentityExpress.Manager.UI.dll; you can run the dll using dotnet IdentityExpress.Manager.UI.dll -bootstrap","title":"Bootstrapping"},{"location":"Bootstrapping/Bootstrapping_Help.html#bootstrapping-adminui","text":"For AdminUI to work out of the box, it has some behaviour turned on by default that inserts the required data into the OpenIddict, and Identity database tables on the app start if missing. If the user table is empty, this also inserts a default user into the database on the first start-up.","title":"Bootstrapping AdminUI"},{"location":"Bootstrapping/Bootstrapping_Help.html#disabling-bootstrapping","text":"You can disable this functionality in the app's configuration. Help for configuring AdminUI can be found here. The bootstrapping in AdminUI is not concurrency safe, so if you were to have multiple instances of AdminUI running, you would need to disable bootstrapping to avoid running into errors when trying to start AdminUI for the first time.","title":"Disabling Bootstrapping"},{"location":"Bootstrapping/Bootstrapping_Help.html#running-manually","text":"If you disable Bootstrapping, we have added the ability to run it manually using the AdminUI binaries via the command line, which can also be done for migrations. You can do this by navigating to your AdminUI install directory and locating the IdentityExpress.Manager.UI.dll; you can run the dll using dotnet IdentityExpress.Manager.UI.dll -bootstrap","title":"Running Manually"},{"location":"Claim_Types/Managing_Claimtypes.html","text":"TODO: Mention being readonly until persistence for claim types is available, V1 will only be ReadOnly Searching for Claim Types You can find Claim Types in the application using the Search functionality. Start typing and the Claim Type will appear if there is a match. Create Claim To create a Claim Type click the \"Add Claim Type\" on the Claim Types list screen. A dialog will appear enabling you to create a new the Claim Type: Once you have entered all details for your Claim Type, click the \"Add\" button, you should then see a success dialogue informing you that your Claim Type has been created. Editing a Claim Type Select the Claim Type you want to edit, this will open the Claim Type details screen. From this screen you can modify the properties of the Claim Type. Once you have made the edits you require, click Save, and you should then see a success dialogue informing you that your changes have been saved. Deleting a Claim Type Claim Types can be deleted through the \"Delete\" button on the Claim Types details screen. On deletion, any user that has a claim of that type will have that claim removed. This action cannot be undone. Reserved Claim Types Some Claim Types that are integral to IdentityServer functionality will be marked as reserved , they cannot be deleted and have restricted editability.","title":"Claim Types"},{"location":"Claim_Types/Managing_Claimtypes.html#todo-mention-being-readonly-until-persistence-for-claim-types-is-available-v1-will-only-be-readonly","text":"","title":"TODO: Mention being readonly until persistence for claim types is available, V1 will only be ReadOnly"},{"location":"Claim_Types/Managing_Claimtypes.html#searching-for-claim-types","text":"You can find Claim Types in the application using the Search functionality. Start typing and the Claim Type will appear if there is a match.","title":"Searching for Claim Types"},{"location":"Claim_Types/Managing_Claimtypes.html#create-claim","text":"To create a Claim Type click the \"Add Claim Type\" on the Claim Types list screen. A dialog will appear enabling you to create a new the Claim Type: Once you have entered all details for your Claim Type, click the \"Add\" button, you should then see a success dialogue informing you that your Claim Type has been created.","title":"Create Claim"},{"location":"Claim_Types/Managing_Claimtypes.html#editing-a-claim-type","text":"Select the Claim Type you want to edit, this will open the Claim Type details screen. From this screen you can modify the properties of the Claim Type. Once you have made the edits you require, click Save, and you should then see a success dialogue informing you that your changes have been saved.","title":"Editing a Claim Type"},{"location":"Claim_Types/Managing_Claimtypes.html#deleting-a-claim-type","text":"Claim Types can be deleted through the \"Delete\" button on the Claim Types details screen. On deletion, any user that has a claim of that type will have that claim removed. This action cannot be undone.","title":"Deleting a Claim Type"},{"location":"Claim_Types/Managing_Claimtypes.html#reserved-claim-types","text":"Some Claim Types that are integral to IdentityServer functionality will be marked as reserved , they cannot be deleted and have restricted editability.","title":"Reserved Claim Types"},{"location":"Configuration_and_Integration/AdminUI_Settings.html","text":"TODO Update for OpenIddict AdminUI is configured using a set of variables that can be provided in various ways, these methods are described here , and if using the NuGet package there is an additional method of configuring AdminUI here . AdminUI Settings Structure Note: In AdminUI 4.2.0 and 5.1.0 onwards, the env.js file is no longer used for configuration and changes do not need to be made to this file. It can be removed if you choose. Logging Settings AzureAppServiceLogging (Optional) Used for debugging the API - see the enable logging page for more details. LoggingMinimumLevel Defaults to info . Supported logging levels are debug info warning error critical LoggingOutputTemplate Defaults to [{Timestamp:dd-MM-yyyy HH:mm:ss} {Level}] {Message}{NewLine}{Exception} . For more infomation see the serilog docs . Database Settings DbProvider Supported types and their values are: SqlServer MySql (Note: AdminUI requires the MySQL setting lower_case_table_names to be false ) PostgreSql IdentityConnectionString The connection string for the Identity database (Users, Claim Types, Roles etc.) IdentityServerConnectionString The connection string for the IdentityServer database (Clients, Resources, Persited Grants etc.) OperationalConnectionString (Optional) The connection string for the Persisted Grants DbContext. If not supplied, AdminUI will use the IdentityServerConnectionString DataProtectionConnectionString (Optional) The connection string for the DataProtectionKey DbContext. If not supplied, AdminUI will use the IdentityServerConnectionString . Only needs configuring if you are using a database to store protection keys. AuditRecordsConnectionString The database connection string for AdminUI audits, if missing will default to the IdentityServerConnectionString StoredProcedureSchemaPrefix (Optional, only for SqlServer provider) Changes schema name for the stored procedures in SqlServer database providers. OperationalStoreSchemaName (Optional) Changes schema name for the Operational Store. If you are planning to use this, read about custom database schema names . ConfigurationStoreSchemaName (Optional) Changes schema name for the Configuration Store. If you are planning to use this, read about custom database schema names . AdminUI Configuration AuthorityUrl The IdentityServer installation protecting AdminUI UiUrl The AdminUI website AdminUIClientId The AdminUI client ID, defaults to admin_ui AdminUICustomScopeName The AdminUI custom scope name, default value is admin_api AdminUIProfileCustomScopeName The AdminUI profile custom scope name, default value is admin_ui_profile AdminUIClientSecret The AdminUI client shared secret value in plain text WebhookClientId The Webhook client ID, defaults to admin_ui_webhooks WebhookClientSecret The Webhook client secret, defaults to a new GUID AdminUIJwtTypes Configures supported JWT types in AdminUI, possible values: All (Default) Suppports both Bearer and DPoP tokens Bearer Supports only Bearer tokens DPoP Supports only DPoP tokens AuditRecordsCulture Language used for generation of audit records, possible values: en-GB (Default) English de German zh-TW Chinese (Traditional) zh-CN Chinese (Simplified) es Spanish fr French AuditReadActions Defaults to true . If false , no audit records will be generated for read actions (e.g when a user views resources though AdminUI) RequireHttpsMetadata When true ensures IdentityServer discovery endpoint uses TLS. Should be true for production PasswordResetEndpoint ... RegistrationConfirmationEndpoint ... ResetMFAEndpoint ... LicenseKey A valid license key for AdminUI TargetIdentityServer4 (Deprecated from version 7.0) If set to true , AdminUI will target IdentityServer4 schema. If set to false, AdminUI will target Duende IdentityServer schema. Defaults to false . DisableBootstrap If true , bootstrapping will not run on app startup. More information about bootstrapping can be found here. Defaults to false . ServeUi If true , SPA will be served by AdminUI using packaged static files. Defaults to true . PasswordPolicy RequireDigit Defaults to true RequireLowercase Defaults to true RequireNonAlphanumeric Defaults to true RequireUppercase Defaults to true RequiredLength Defaults to 6 RequiredUniqueChars Defaults to 1 UsernamePolicy AllowedUserNameCharacters - Defaults to abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._@+ RequireUniqueEmail - Defaults to true ReferenceTokenOptions UseReferenceTokens ... Secret ... FeatureFlags DefaultUserValidation - Defaults to false . If set to true AdminUI will not prompt you to remove the default user if present. AddUserPassword Defaults to false . If true , allows for setting a users password on creation (this is for demo purposes only, do not use in production), see more here UserManagementDisabled ... EnableEnforcerAuthorization - Defaults to false . If set to true will use the Enforcer authorization engine for more fine grained access control. More info can be found in our 6.3 release article EnableSharedScopes - Defaults to false . If set to true AdminUI will allow scopes to be shared between protected resources. EnableSessionManagement - Defaults to true . Allows the management of the IdentityServer Duende session management feature . If set to false AdminUI will not show the SessionManagment tables when viewing or editing users. EnableDynamicAuthentication - Defaults to Duende . Allows the management of Dynamic Authentication through AdminUI. Options are Disabled Dynamic Authentication is disabled. Duende Duende IdentityServer Dynamic Authentication is enabled. Data Protection DataProtection Used for configuration of Cookie protection and peristence. Persistence - The type of persistence can be FileSystem or Database, these require different setup as shown below Type - FileSystem Location - Location to persist keys OR Type - Database DbProvider Supported types and their values are: SqlServer MySql (Note: AdminUI requires the MySQL setting lower_case_table_names to be false ) PostgreSql Protection The certficate or keyvault that will protect the cookies. The two available types are KeyVault and Certifcate. A Certificate can be provided by location or by thumbprint. Type - KeyVault KeyIdentifier - The Azure KeyVault certificate identifier used for key encryption. ClientId (not in new Settings Model, see ) - The Application Client Id Vault (not in new Settings Model, see ) - The KeyVault public Uri Secret (not in new Settings Model, see ) - (Optional) The client secret to use for authentication. Optional valid only for Azure hosted scenarios OR Type - Certificate (To protect with certificate you can provide either a thumbprint or a location) CertificateType - Thumbprint Thumbprint - The thumbprint of the certificate that is installed either for the user or the machine. OR Type - Certificate (To protect with certificate you can provide either a thumbprint or a location) CertificateType - File Location - The location on disk of the certificate. We recommend using a PFX file as private key access is necessary. Password (Optional) - The password for the certificate TargetIdentityServer4 Flag Deprecated from v7.0 The TargetIdentityServer4 flag in the API Configuration is used to determine what version of IdentityServer you want your AdminUI to target. If you're working with an IdentityServer4 database, you'll want to set this flag to true . If you're working with a Duende IdentityServer database, you'll want to set this flag to false . This configuration setting will change how AdminUI displays certain entities such as Protected Resources, as well as if it will display certain views. This setting will also change what migrations will be run by the migration tool. Here is some example configuration files: appsettings.json file IAdminUISettings implementation","title":"AdminUI Settings"},{"location":"Configuration_and_Integration/AdminUI_Settings.html#todo-update-for-openiddict","text":"AdminUI is configured using a set of variables that can be provided in various ways, these methods are described here , and if using the NuGet package there is an additional method of configuring AdminUI here .","title":"TODO Update for OpenIddict"},{"location":"Configuration_and_Integration/AdminUI_Settings.html#adminui-settings-structure","text":"Note: In AdminUI 4.2.0 and 5.1.0 onwards, the env.js file is no longer used for configuration and changes do not need to be made to this file. It can be removed if you choose.","title":"AdminUI Settings Structure"},{"location":"Configuration_and_Integration/AdminUI_Settings.html#logging-settings","text":"AzureAppServiceLogging (Optional) Used for debugging the API - see the enable logging page for more details. LoggingMinimumLevel Defaults to info . Supported logging levels are debug info warning error critical LoggingOutputTemplate Defaults to [{Timestamp:dd-MM-yyyy HH:mm:ss} {Level}] {Message}{NewLine}{Exception} . For more infomation see the serilog docs .","title":"Logging Settings"},{"location":"Configuration_and_Integration/AdminUI_Settings.html#database-settings","text":"DbProvider Supported types and their values are: SqlServer MySql (Note: AdminUI requires the MySQL setting lower_case_table_names to be false ) PostgreSql IdentityConnectionString The connection string for the Identity database (Users, Claim Types, Roles etc.) IdentityServerConnectionString The connection string for the IdentityServer database (Clients, Resources, Persited Grants etc.) OperationalConnectionString (Optional) The connection string for the Persisted Grants DbContext. If not supplied, AdminUI will use the IdentityServerConnectionString DataProtectionConnectionString (Optional) The connection string for the DataProtectionKey DbContext. If not supplied, AdminUI will use the IdentityServerConnectionString . Only needs configuring if you are using a database to store protection keys. AuditRecordsConnectionString The database connection string for AdminUI audits, if missing will default to the IdentityServerConnectionString StoredProcedureSchemaPrefix (Optional, only for SqlServer provider) Changes schema name for the stored procedures in SqlServer database providers. OperationalStoreSchemaName (Optional) Changes schema name for the Operational Store. If you are planning to use this, read about custom database schema names . ConfigurationStoreSchemaName (Optional) Changes schema name for the Configuration Store. If you are planning to use this, read about custom database schema names .","title":"Database Settings"},{"location":"Configuration_and_Integration/AdminUI_Settings.html#adminui-configuration","text":"AuthorityUrl The IdentityServer installation protecting AdminUI UiUrl The AdminUI website AdminUIClientId The AdminUI client ID, defaults to admin_ui AdminUICustomScopeName The AdminUI custom scope name, default value is admin_api AdminUIProfileCustomScopeName The AdminUI profile custom scope name, default value is admin_ui_profile AdminUIClientSecret The AdminUI client shared secret value in plain text WebhookClientId The Webhook client ID, defaults to admin_ui_webhooks WebhookClientSecret The Webhook client secret, defaults to a new GUID AdminUIJwtTypes Configures supported JWT types in AdminUI, possible values: All (Default) Suppports both Bearer and DPoP tokens Bearer Supports only Bearer tokens DPoP Supports only DPoP tokens AuditRecordsCulture Language used for generation of audit records, possible values: en-GB (Default) English de German zh-TW Chinese (Traditional) zh-CN Chinese (Simplified) es Spanish fr French AuditReadActions Defaults to true . If false , no audit records will be generated for read actions (e.g when a user views resources though AdminUI) RequireHttpsMetadata When true ensures IdentityServer discovery endpoint uses TLS. Should be true for production PasswordResetEndpoint ... RegistrationConfirmationEndpoint ... ResetMFAEndpoint ... LicenseKey A valid license key for AdminUI TargetIdentityServer4 (Deprecated from version 7.0) If set to true , AdminUI will target IdentityServer4 schema. If set to false, AdminUI will target Duende IdentityServer schema. Defaults to false . DisableBootstrap If true , bootstrapping will not run on app startup. More information about bootstrapping can be found here. Defaults to false . ServeUi If true , SPA will be served by AdminUI using packaged static files. Defaults to true . PasswordPolicy RequireDigit Defaults to true RequireLowercase Defaults to true RequireNonAlphanumeric Defaults to true RequireUppercase Defaults to true RequiredLength Defaults to 6 RequiredUniqueChars Defaults to 1 UsernamePolicy AllowedUserNameCharacters - Defaults to abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._@+ RequireUniqueEmail - Defaults to true ReferenceTokenOptions UseReferenceTokens ... Secret ... FeatureFlags DefaultUserValidation - Defaults to false . If set to true AdminUI will not prompt you to remove the default user if present. AddUserPassword Defaults to false . If true , allows for setting a users password on creation (this is for demo purposes only, do not use in production), see more here UserManagementDisabled ... EnableEnforcerAuthorization - Defaults to false . If set to true will use the Enforcer authorization engine for more fine grained access control. More info can be found in our 6.3 release article EnableSharedScopes - Defaults to false . If set to true AdminUI will allow scopes to be shared between protected resources. EnableSessionManagement - Defaults to true . Allows the management of the IdentityServer Duende session management feature . If set to false AdminUI will not show the SessionManagment tables when viewing or editing users. EnableDynamicAuthentication - Defaults to Duende . Allows the management of Dynamic Authentication through AdminUI. Options are Disabled Dynamic Authentication is disabled. Duende Duende IdentityServer Dynamic Authentication is enabled.","title":"AdminUI Configuration"},{"location":"Configuration_and_Integration/AdminUI_Settings.html#data-protection","text":"DataProtection Used for configuration of Cookie protection and peristence. Persistence - The type of persistence can be FileSystem or Database, these require different setup as shown below Type - FileSystem Location - Location to persist keys OR Type - Database DbProvider Supported types and their values are: SqlServer MySql (Note: AdminUI requires the MySQL setting lower_case_table_names to be false ) PostgreSql Protection The certficate or keyvault that will protect the cookies. The two available types are KeyVault and Certifcate. A Certificate can be provided by location or by thumbprint. Type - KeyVault KeyIdentifier - The Azure KeyVault certificate identifier used for key encryption. ClientId (not in new Settings Model, see ) - The Application Client Id Vault (not in new Settings Model, see ) - The KeyVault public Uri Secret (not in new Settings Model, see ) - (Optional) The client secret to use for authentication. Optional valid only for Azure hosted scenarios OR Type - Certificate (To protect with certificate you can provide either a thumbprint or a location) CertificateType - Thumbprint Thumbprint - The thumbprint of the certificate that is installed either for the user or the machine. OR Type - Certificate (To protect with certificate you can provide either a thumbprint or a location) CertificateType - File Location - The location on disk of the certificate. We recommend using a PFX file as private key access is necessary. Password (Optional) - The password for the certificate","title":"Data Protection"},{"location":"Configuration_and_Integration/AdminUI_Settings.html#targetidentityserver4-flag-deprecated-from-v70","text":"The TargetIdentityServer4 flag in the API Configuration is used to determine what version of IdentityServer you want your AdminUI to target. If you're working with an IdentityServer4 database, you'll want to set this flag to true . If you're working with a Duende IdentityServer database, you'll want to set this flag to false . This configuration setting will change how AdminUI displays certain entities such as Protected Resources, as well as if it will display certain views. This setting will also change what migrations will be run by the migration tool.","title":"TargetIdentityServer4 Flag Deprecated from v7.0"},{"location":"Configuration_and_Integration/AdminUI_Settings.html#here-is-some-example-configuration-files","text":"appsettings.json file IAdminUISettings implementation","title":"Here is some example configuration files:"},{"location":"Configuration_and_Integration/Configuring_AdminUI.html","text":"TODO Update AdminUI configuration is set using environment variables and appsettings.json. The structure of AdminUIs settings is defined in AdminUI Settings . Configuring via Environment Variables Environment variables may be set in many different way depending on you deployment strategy, this could be via any cloud hosting platform, docker compose files, etc... Examples of this can be Note: Environments variables are nested with either __ (Linux environments) or : (Windows environments). E.g: DataProtection__Persistence__Type or DataProtection:Persistence:Type Running AdminUI On a Different Port If you need to configure the ports for the website you can add the following section to your appsettings.json file: \"Kestrel\": { \"Endpoints\": { \"Http\": { //Your new Url Here \"Url\": \"http://localhost:5020\" } } } If you would like to see all possible config options for the Kestrel property you can find them here . Running AdminUI On a Different Path If you are not running AdminUI from the root URL (e.g., using a path like https://generalweb/myadminui), an additional step is required. This is necessary because the index.html file, from which the SPA starts running, has a default reference to the root of the URL: <base href=\"/\"> This refers to an HTML path, so adding a full stop before the slash will not work in all the cases. Instead, you need to update the href with the AdminUI path. The specific steps for this vary depending on how you deploy AdminUI: Using Nuget package You need to include the property in your csproj file. This property will overwrite the base href after building the index.html file. Using the example mentioned earlier (https://generalweb/myadminui), the configuration would follow this schema: <Project> <PropertyGroup> <AdminUiPath>/myadminui/</AdminUiPath> </PropertyGroup> </Project> Remember to include a slash at the end of the path. This has to be done from the csproj (build pipeline) as the Nuget AdminUI will replace the html files on build. Using Zips or installer In this case, manually change the path in the index.html file located in the wwwroot folder of your AdminUI. Do not confuse it with the parent wwwroot that holds the AdminUI folder and other apps. Following the example (https://generalweb/myadminui), the updated line should be: <base href=\"/myadminui/\"> Remember to include a slash at the end of the path. Using Docker In the AdminUI Dockerfile, include the following command changing \"myadminui\" with your own path: sed -i 's/<base href=\"\\/\">/<base href=\"\\/myadminui\\/\">/' /wwwroot/admin/index.html This has to be done from Docker as the Nuget AdminUI will replace the html files on build. Remember to include a slash at the end of the path. Also, notice the forward slashes are escaped with a backslash. Example appsettings.json: { \"UiUrl\": \"http://localhost:5000\", \"AuthorityUrl\": \"https://localhost:5003\", \"AzureAppServiceLogging\": false, \"LoggingMinimumLevel\": \"Info\", \"EFLoggingMinimumLevel\": \"Warning\", \"DbProvider\": \"SqlServer\", \"IdentityConnectionString\": \"Server=localhost;User Id=AdminUI;Password=Password123!;Database=IdentityExpressDb;\", \"IdentityServerConnectionString\": \"Server=localhost;User Id=AdminUI;Password=Password123!;Database=IdentityExpressDb;\", \"AuditRecordsConnectionString\": \"Server=localhost;User Id=AdminUI;Password=Password123!;Database=IdentityExpressDb;\", \"DataProtectionConnectionString\": \"Server=localhost;User Id=AdminUI;Password=Password123!;Database=IdentityExpressDb;\", \"RequireHttpsMetadata\": false, \"LicenseKey\": \"\", \"PasswordPolicy\": { \"RequireDigit\": true, \"RequireLowercase\": true, \"RequireNonAlphanumeric\": true, \"RequireUppercase\": true, \"RequiredLength\": 6, \"RequiredUniqueChars\": 1 }, \"UsernamePolicy\": { \"AllowedUserNameCharacters\": \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._@+\", \"RequireUniqueEmail\": false }, \"ReferenceTokens\": { \"UseReferenceTokens\": false, \"Secret\": \"\" }, \"TargetIdentityServer4\": false, \"DisableBootstrap\": false, \"ServeUi\": true, \"FeatureFlags\": { \"DefaultUserValidation\": true, \"AddUserPassword\": false, \"EnableEnforcerAuthorization\": false, \"EnableSharedScopes\": false, \"EnableSessionManagement\": true, \"EnableDynamicAuthentication\": \"Duende\" }, \"DataProtection\": { \"Persistence\": { \"Type\": \"Database\", \"DbProvider\": \"SqlServer\", \"DataProtectionConnectionString\": \"Server=localhost;User Id=AdminUI;Password=Password123!;Database=IdentityExpressDb;\" }, \"Protection\": { \"Type\": \"Certificate\", \"CertificateType\": \"Thumbprint\", \"Thumbprint\": \"c09fb8e928ef97fbd2a78be9bfe99341a2175af4\" } } }","title":"Configuring AdminUI"},{"location":"Configuration_and_Integration/Configuring_AdminUI.html#todo-update","text":"AdminUI configuration is set using environment variables and appsettings.json. The structure of AdminUIs settings is defined in AdminUI Settings .","title":"TODO Update"},{"location":"Configuration_and_Integration/Configuring_AdminUI.html#configuring-via-environment-variables","text":"Environment variables may be set in many different way depending on you deployment strategy, this could be via any cloud hosting platform, docker compose files, etc... Examples of this can be Note: Environments variables are nested with either __ (Linux environments) or : (Windows environments). E.g: DataProtection__Persistence__Type or DataProtection:Persistence:Type","title":"Configuring via Environment Variables"},{"location":"Configuration_and_Integration/Configuring_AdminUI.html#running-adminui-on-a-different-port","text":"If you need to configure the ports for the website you can add the following section to your appsettings.json file: \"Kestrel\": { \"Endpoints\": { \"Http\": { //Your new Url Here \"Url\": \"http://localhost:5020\" } } } If you would like to see all possible config options for the Kestrel property you can find them here .","title":"Running AdminUI On a Different Port"},{"location":"Configuration_and_Integration/Configuring_AdminUI.html#running-adminui-on-a-different-path","text":"If you are not running AdminUI from the root URL (e.g., using a path like https://generalweb/myadminui), an additional step is required. This is necessary because the index.html file, from which the SPA starts running, has a default reference to the root of the URL: <base href=\"/\"> This refers to an HTML path, so adding a full stop before the slash will not work in all the cases. Instead, you need to update the href with the AdminUI path. The specific steps for this vary depending on how you deploy AdminUI:","title":"Running AdminUI On a Different Path"},{"location":"Configuration_and_Integration/Configuring_AdminUI.html#using-nuget-package","text":"You need to include the property in your csproj file. This property will overwrite the base href after building the index.html file. Using the example mentioned earlier (https://generalweb/myadminui), the configuration would follow this schema: <Project> <PropertyGroup> <AdminUiPath>/myadminui/</AdminUiPath> </PropertyGroup> </Project> Remember to include a slash at the end of the path. This has to be done from the csproj (build pipeline) as the Nuget AdminUI will replace the html files on build.","title":"Using Nuget package"},{"location":"Configuration_and_Integration/Configuring_AdminUI.html#using-zips-or-installer","text":"In this case, manually change the path in the index.html file located in the wwwroot folder of your AdminUI. Do not confuse it with the parent wwwroot that holds the AdminUI folder and other apps. Following the example (https://generalweb/myadminui), the updated line should be: <base href=\"/myadminui/\"> Remember to include a slash at the end of the path.","title":"Using Zips or installer"},{"location":"Configuration_and_Integration/Configuring_AdminUI.html#using-docker","text":"In the AdminUI Dockerfile, include the following command changing \"myadminui\" with your own path: sed -i 's/<base href=\"\\/\">/<base href=\"\\/myadminui\\/\">/' /wwwroot/admin/index.html This has to be done from Docker as the Nuget AdminUI will replace the html files on build. Remember to include a slash at the end of the path. Also, notice the forward slashes are escaped with a backslash.","title":"Using Docker"},{"location":"Configuration_and_Integration/Configuring_AdminUI.html#example-appsettingsjson","text":"{ \"UiUrl\": \"http://localhost:5000\", \"AuthorityUrl\": \"https://localhost:5003\", \"AzureAppServiceLogging\": false, \"LoggingMinimumLevel\": \"Info\", \"EFLoggingMinimumLevel\": \"Warning\", \"DbProvider\": \"SqlServer\", \"IdentityConnectionString\": \"Server=localhost;User Id=AdminUI;Password=Password123!;Database=IdentityExpressDb;\", \"IdentityServerConnectionString\": \"Server=localhost;User Id=AdminUI;Password=Password123!;Database=IdentityExpressDb;\", \"AuditRecordsConnectionString\": \"Server=localhost;User Id=AdminUI;Password=Password123!;Database=IdentityExpressDb;\", \"DataProtectionConnectionString\": \"Server=localhost;User Id=AdminUI;Password=Password123!;Database=IdentityExpressDb;\", \"RequireHttpsMetadata\": false, \"LicenseKey\": \"\", \"PasswordPolicy\": { \"RequireDigit\": true, \"RequireLowercase\": true, \"RequireNonAlphanumeric\": true, \"RequireUppercase\": true, \"RequiredLength\": 6, \"RequiredUniqueChars\": 1 }, \"UsernamePolicy\": { \"AllowedUserNameCharacters\": \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._@+\", \"RequireUniqueEmail\": false }, \"ReferenceTokens\": { \"UseReferenceTokens\": false, \"Secret\": \"\" }, \"TargetIdentityServer4\": false, \"DisableBootstrap\": false, \"ServeUi\": true, \"FeatureFlags\": { \"DefaultUserValidation\": true, \"AddUserPassword\": false, \"EnableEnforcerAuthorization\": false, \"EnableSharedScopes\": false, \"EnableSessionManagement\": true, \"EnableDynamicAuthentication\": \"Duende\" }, \"DataProtection\": { \"Persistence\": { \"Type\": \"Database\", \"DbProvider\": \"SqlServer\", \"DataProtectionConnectionString\": \"Server=localhost;User Id=AdminUI;Password=Password123!;Database=IdentityExpressDb;\" }, \"Protection\": { \"Type\": \"Certificate\", \"CertificateType\": \"Thumbprint\", \"Thumbprint\": \"c09fb8e928ef97fbd2a78be9bfe99341a2175af4\" } } }","title":"Example appsettings.json:"},{"location":"Configuration_and_Integration/Configuring_AdminUI_NuGet.html","text":"TODO Update When using the AdminUI nuget package there is a new method of configuring AdminUI, this method allows you to implement your own custom implementation of the IAdminUISettings interface. This is in addition to the existing methods of configuring AdminUI. Logging settings Logging settings are still obtained from the environment so must be set via an appsettings.json file, or as envorments variables. Using the New Settings Model From AdminUI 6.8 onwards there is a new way of configuring the settings for AdminUI that doesn't rely on reading configuration data from key-value pairs using configuration sources such as appsettings.json or environment variables. The new way to define settings is via the new IAdminUISettings interface: public class MyAdminUISettings : IAdminUISettings { public string DbProvider { get; set; } ... } This is how you can set it in Program.cs: // Program.cs var builder = WebApplication.CreateBuilder(args); // Populate settings from anywhere you like var settings = new MyAdminUISettings(); builder.Services.AddAdminUI(settings); var app = builder.Build(); app.UseAdminUI(); app.Run(); If you prefer, we still support reading settings the old way by reading configuration data from key-value pairs using configuration sources such as appsettings.json or environment variables: // Program.cs var builder = WebApplication.CreateBuilder(args); builder.Services.AddAdminUI(new AdminUISettings(builder.Configuration)); var app = builder.Build(); app.UseAdminUI(); app.Run(); Also for backwards compatibility, we still support the old version of AddAdminUI that reads configuration data from key-value pairs using configuration sources such as appsettings.json or environment variables, but this will be deprecated in the future: // Program.cs var builder = WebApplication.CreateBuilder(args); builder.Services .AddAdminUI( options => { // Override default options here } ); var app = builder.Build(); app.UseAdminUI(); app.Run(); Configuring KeyVault DataProtection When using KeyVault data protection with AdminUI NuGet package you only need to set the key identifier in the AdminUI settings as the intention is you would configure KeyVault access yourself making the certificates available to AdminUI throuhgh IConfiguration. A simple way of doing this is provided with the Azure.Extensions.AspNetCore.Configuration.Secrets package which provides an extension method called AddAzureKeyVault. This is why the ClientId , Vault , and Secret are not present in the new AdminUI configuration model.","title":"Configuring AdminUI (NuGet)"},{"location":"Configuration_and_Integration/Configuring_AdminUI_NuGet.html#todo-update","text":"When using the AdminUI nuget package there is a new method of configuring AdminUI, this method allows you to implement your own custom implementation of the IAdminUISettings interface. This is in addition to the existing methods of configuring AdminUI.","title":"TODO Update"},{"location":"Configuration_and_Integration/Configuring_AdminUI_NuGet.html#logging-settings","text":"Logging settings are still obtained from the environment so must be set via an appsettings.json file, or as envorments variables.","title":"Logging settings"},{"location":"Configuration_and_Integration/Configuring_AdminUI_NuGet.html#using-the-new-settings-model","text":"From AdminUI 6.8 onwards there is a new way of configuring the settings for AdminUI that doesn't rely on reading configuration data from key-value pairs using configuration sources such as appsettings.json or environment variables. The new way to define settings is via the new IAdminUISettings interface: public class MyAdminUISettings : IAdminUISettings { public string DbProvider { get; set; } ... } This is how you can set it in Program.cs: // Program.cs var builder = WebApplication.CreateBuilder(args); // Populate settings from anywhere you like var settings = new MyAdminUISettings(); builder.Services.AddAdminUI(settings); var app = builder.Build(); app.UseAdminUI(); app.Run(); If you prefer, we still support reading settings the old way by reading configuration data from key-value pairs using configuration sources such as appsettings.json or environment variables: // Program.cs var builder = WebApplication.CreateBuilder(args); builder.Services.AddAdminUI(new AdminUISettings(builder.Configuration)); var app = builder.Build(); app.UseAdminUI(); app.Run(); Also for backwards compatibility, we still support the old version of AddAdminUI that reads configuration data from key-value pairs using configuration sources such as appsettings.json or environment variables, but this will be deprecated in the future: // Program.cs var builder = WebApplication.CreateBuilder(args); builder.Services .AddAdminUI( options => { // Override default options here } ); var app = builder.Build(); app.UseAdminUI(); app.Run();","title":"Using the New Settings Model"},{"location":"Configuration_and_Integration/Configuring_AdminUI_NuGet.html#configuring-keyvault-dataprotection","text":"When using KeyVault data protection with AdminUI NuGet package you only need to set the key identifier in the AdminUI settings as the intention is you would configure KeyVault access yourself making the certificates available to AdminUI throuhgh IConfiguration. A simple way of doing this is provided with the Azure.Extensions.AspNetCore.Configuration.Secrets package which provides an extension method called AddAzureKeyVault. This is why the ClientId , Vault , and Secret are not present in the new AdminUI configuration model.","title":"Configuring KeyVault DataProtection"},{"location":"Configuration_and_Integration/Enabling_Logging.html","text":"TODO Update for OpenIddict AdminUI outputs to the console by default, which most hosting options can read from. Logging with IIS Setting the stdoutLogEnabled attribute to true in the web.config or IIS configuration manager enables logging. This attribute is found in: system.webServer > aspNetCore . The log file output location is controlled by the stdoutLogFile attribute. In the example below, logging has been enabled in the web.config and all log files will be output to the .\\logs\\ directory. The log files will also be prefixed with stdout : <aspNetCore stdoutLogEnabled=\"true\" stdoutLogFile=\".\\logs\\stdout\" ...> ... </aspNetCore> Note: Ensure that the folder exists and that IIS has permissions to write to it. Logging with Azure Our recommended way to get logs out of AdminUI is to: Set the AzureAppServiceLogging application setting to true. Enable Application Logging (filesystem) in the App Service Logs section of the Azure portal: This will automatically set the log location of AdminUI to Home\\LogFiles\\Application\\Admin in the app service. Using this option will allow you to see logs from the Log stream page in the Azure portal. If you are having trouble getting logs out of your Azure installation by using the setting above then you can change the web.config. To get logs out in this scenario you can change the stdoutLogFile to a location in the log files directory. This should look something like the following: <aspNetCore processPath=\".\\IdentityExpress.Manager.UI.exe\" arguments=\"\" stdoutLogEnabled=\"true\" stdoutLogFile=\"\\\\?\\%home%\\LogFiles\\AdminUI\" ...> In your AdminUI web app, go to \"Advanced Tools\" and click on \"Go\". Now click on \"Debug console\" and select \"Powershell\". Leave it a second to load and then navigate to this file: site\\wwwroot\\web.config Change the \"stdoutLogEnabled\" value to \"true\" and save: (You can also modify the where log files on \u201cstdoutLogFile\u201d) Now if you restart your web app and navigate back to the home folder and then to \"Logfiles\" you should fine log files named something similar to \"stdout_34872356554.log\" Alternatively if you deploy AdminUI as part of your CI/CD process as of 4.2.0 and 5.1.0 we supply an xml transform file that does the above for you on deployment. The caveat is that you wont see these logs in the Log Stream section of Azure. AdminUI will now output logs under the LogFiles\\Application directory at the root of your app service. Logging with Docker Docker should automatically record any logs with Docker logging . Most tools and systems that work with Docker logging will continue to work as expected. Minimum Entity Framework Logging Level By default, the AdminUI will only log Warning level database commands. To change this, update the EFLoggingMinimumLevel variable in the AdminUI config.","title":"Enabling Logging"},{"location":"Configuration_and_Integration/Enabling_Logging.html#todo-update-for-openiddict","text":"AdminUI outputs to the console by default, which most hosting options can read from.","title":"TODO Update for OpenIddict"},{"location":"Configuration_and_Integration/Enabling_Logging.html#logging-with-iis","text":"Setting the stdoutLogEnabled attribute to true in the web.config or IIS configuration manager enables logging. This attribute is found in: system.webServer > aspNetCore . The log file output location is controlled by the stdoutLogFile attribute. In the example below, logging has been enabled in the web.config and all log files will be output to the .\\logs\\ directory. The log files will also be prefixed with stdout : <aspNetCore stdoutLogEnabled=\"true\" stdoutLogFile=\".\\logs\\stdout\" ...> ... </aspNetCore> Note: Ensure that the folder exists and that IIS has permissions to write to it.","title":"Logging with IIS"},{"location":"Configuration_and_Integration/Enabling_Logging.html#logging-with-azure","text":"Our recommended way to get logs out of AdminUI is to: Set the AzureAppServiceLogging application setting to true. Enable Application Logging (filesystem) in the App Service Logs section of the Azure portal: This will automatically set the log location of AdminUI to Home\\LogFiles\\Application\\Admin in the app service. Using this option will allow you to see logs from the Log stream page in the Azure portal. If you are having trouble getting logs out of your Azure installation by using the setting above then you can change the web.config. To get logs out in this scenario you can change the stdoutLogFile to a location in the log files directory. This should look something like the following: <aspNetCore processPath=\".\\IdentityExpress.Manager.UI.exe\" arguments=\"\" stdoutLogEnabled=\"true\" stdoutLogFile=\"\\\\?\\%home%\\LogFiles\\AdminUI\" ...> In your AdminUI web app, go to \"Advanced Tools\" and click on \"Go\". Now click on \"Debug console\" and select \"Powershell\". Leave it a second to load and then navigate to this file: site\\wwwroot\\web.config Change the \"stdoutLogEnabled\" value to \"true\" and save: (You can also modify the where log files on \u201cstdoutLogFile\u201d) Now if you restart your web app and navigate back to the home folder and then to \"Logfiles\" you should fine log files named something similar to \"stdout_34872356554.log\" Alternatively if you deploy AdminUI as part of your CI/CD process as of 4.2.0 and 5.1.0 we supply an xml transform file that does the above for you on deployment. The caveat is that you wont see these logs in the Log Stream section of Azure. AdminUI will now output logs under the LogFiles\\Application directory at the root of your app service.","title":"Logging with Azure"},{"location":"Configuration_and_Integration/Enabling_Logging.html#logging-with-docker","text":"Docker should automatically record any logs with Docker logging . Most tools and systems that work with Docker logging will continue to work as expected.","title":"Logging with Docker"},{"location":"Configuration_and_Integration/Enabling_Logging.html#minimum-entity-framework-logging-level","text":"By default, the AdminUI will only log Warning level database commands. To change this, update the EFLoggingMinimumLevel variable in the AdminUI config.","title":"Minimum Entity Framework Logging Level"},{"location":"Configuration_and_Integration/Integrating_with_OpenIddict.html","text":"TODO Create","title":"Integrating with OpenIddict"},{"location":"Configuration_and_Integration/Integrating_with_OpenIddict.html#todo-create","text":"","title":"TODO Create"},{"location":"Configuration_and_Integration/Integrating_with_Quickstarts.html","text":"TODO Create","title":"Integrating with Quickstarts"},{"location":"Configuration_and_Integration/Integrating_with_Quickstarts.html#todo-create","text":"","title":"TODO Create"},{"location":"CustomDatabaseConnections/Overview.html","text":"Update for OpenIddict Overview This page assumes you have read the AdminUI as a NuGet package documentation area. The AdminUI NuGet package uses a factory abstraction for creating database connections. When using the AdminUI NuGet package in your web applications, you can use the default implementation. This uses connection strings in configuration to create the connection. The connection strings it uses are in appSettings.json and cover 5 different areas of functionality: \"IdentityConnectionString\": \"...\", \"IdentityServerConnectionString\": \"...\", \"AuditRecordsConnectionString\": \"...\", \"DataProtectionConnectionString\": \"...\", \"OperationalConnectionString\": \"...\", \"DataProtectionConnectionString\": \"...\", You can get away with just using the first 2 as the last 3 will default to the second one. See here for more details. Alternatively, you can write your own connection factory implementation to create connections using a different strategy. This opens up AdminUI to users who may have not been able to take advantage of it in the past - perhaps users who deploy AdminUI in Azure and authenticates with the database via an Azure AD token. Changes As mentioned above, AdminUI\u2019s connection creation has historically been based purely on using connection strings. AdminUI 6.7 adds a pluggable abstraction that allows for the decoupling from this old strategy. The abstraction is IDatabaseConnectionFactory and it initialized in AdminUI's service layer with the default implementation. The interface is defined thus: public interface IDatabaseConnectionFactory { // Create connection for the Identity database (Users, Claim Types, Roles etc.) public DbConnection CreateIdentityConnection(bool migration = false); // Create connection for the IdentityServer database (Clients, Resources, Persited Grants etc.) public DbConnection CreateIdentityServerConnection(bool migration = false); // Create connection for the Auditing DbContext public DbConnection CreateAuditRecordsConnection(bool migration = false); // Create connection for the Persisted Grants DbContext public DbConnection CreateOperationalConnection(bool migration = false); // Creates connection for the DataProtectionKey DbContext public DbConnection CreateDataProtectionConnection(bool migration = false); } The migration parameter in each method is used to distinguish whether the method is called by AdminUI as part of its normal operation or when running migrations (in case you need to distinguish). To change the default implementation, simply implement this interface and tell AdminUI to use it instead of the default. Starting point To get started, take the result of the NuGet Installation and update the service registration to the following: builder.Services .AddAdminUI( options => { options.DatabaseConnectionFactoryType = DatabaseConnectionFactoryType.Custom; }) .WithConnectionFactory<MyCustomConnectionFactory>(); The WithConnectionFactory<MyCustomConnectionFactory>() method replaces the default connection factory implementation with that defined by MyCustomConnectionFactory class that you write. That's it! Additional Considerations If the custom connection factory has additional interfaces injected into its constructor that are unknown to AdminUI then these will have to be registered with the DI container in the usual way using builder.Services , for example, if your custom connection factory implementation looks like this: public class MyCustomConnectionFactory : IDatabaseConnectionFactory { public MyCustomConnectionFactory(IConfiguration configuration, IMyOtherInterface myOtherInterface) { ... } ... } then the service registration might look like this: builder.Services.AddSingleton<IMyOtherInterface, MyOtherInterfaceImplementation>(); builder.Services .AddAdminUI( options => { options.DatabaseConnectionFactoryType = DatabaseConnectionFactoryType.Custom; }) .WithConnectionFactory<MyCustomConnectionFactory>(); Sample code A sample of how to replace the connection factory can be found on our GitHub in the CustomDatabaseConnection project. Remember to fill in the CustomConnectionFactoryConnectionString connection string and the license key in appSettings.json .","title":"Custom Database Connections"},{"location":"CustomDatabaseConnections/Overview.html#update-for-openiddict","text":"","title":"Update for OpenIddict"},{"location":"CustomDatabaseConnections/Overview.html#overview","text":"This page assumes you have read the AdminUI as a NuGet package documentation area. The AdminUI NuGet package uses a factory abstraction for creating database connections. When using the AdminUI NuGet package in your web applications, you can use the default implementation. This uses connection strings in configuration to create the connection. The connection strings it uses are in appSettings.json and cover 5 different areas of functionality: \"IdentityConnectionString\": \"...\", \"IdentityServerConnectionString\": \"...\", \"AuditRecordsConnectionString\": \"...\", \"DataProtectionConnectionString\": \"...\", \"OperationalConnectionString\": \"...\", \"DataProtectionConnectionString\": \"...\", You can get away with just using the first 2 as the last 3 will default to the second one. See here for more details. Alternatively, you can write your own connection factory implementation to create connections using a different strategy. This opens up AdminUI to users who may have not been able to take advantage of it in the past - perhaps users who deploy AdminUI in Azure and authenticates with the database via an Azure AD token.","title":"Overview"},{"location":"CustomDatabaseConnections/Overview.html#changes","text":"As mentioned above, AdminUI\u2019s connection creation has historically been based purely on using connection strings. AdminUI 6.7 adds a pluggable abstraction that allows for the decoupling from this old strategy. The abstraction is IDatabaseConnectionFactory and it initialized in AdminUI's service layer with the default implementation. The interface is defined thus: public interface IDatabaseConnectionFactory { // Create connection for the Identity database (Users, Claim Types, Roles etc.) public DbConnection CreateIdentityConnection(bool migration = false); // Create connection for the IdentityServer database (Clients, Resources, Persited Grants etc.) public DbConnection CreateIdentityServerConnection(bool migration = false); // Create connection for the Auditing DbContext public DbConnection CreateAuditRecordsConnection(bool migration = false); // Create connection for the Persisted Grants DbContext public DbConnection CreateOperationalConnection(bool migration = false); // Creates connection for the DataProtectionKey DbContext public DbConnection CreateDataProtectionConnection(bool migration = false); } The migration parameter in each method is used to distinguish whether the method is called by AdminUI as part of its normal operation or when running migrations (in case you need to distinguish). To change the default implementation, simply implement this interface and tell AdminUI to use it instead of the default.","title":"Changes"},{"location":"CustomDatabaseConnections/Overview.html#starting-point","text":"To get started, take the result of the NuGet Installation and update the service registration to the following: builder.Services .AddAdminUI( options => { options.DatabaseConnectionFactoryType = DatabaseConnectionFactoryType.Custom; }) .WithConnectionFactory<MyCustomConnectionFactory>(); The WithConnectionFactory<MyCustomConnectionFactory>() method replaces the default connection factory implementation with that defined by MyCustomConnectionFactory class that you write. That's it!","title":"Starting point"},{"location":"CustomDatabaseConnections/Overview.html#additional-considerations","text":"If the custom connection factory has additional interfaces injected into its constructor that are unknown to AdminUI then these will have to be registered with the DI container in the usual way using builder.Services , for example, if your custom connection factory implementation looks like this: public class MyCustomConnectionFactory : IDatabaseConnectionFactory { public MyCustomConnectionFactory(IConfiguration configuration, IMyOtherInterface myOtherInterface) { ... } ... } then the service registration might look like this: builder.Services.AddSingleton<IMyOtherInterface, MyOtherInterfaceImplementation>(); builder.Services .AddAdminUI( options => { options.DatabaseConnectionFactoryType = DatabaseConnectionFactoryType.Custom; }) .WithConnectionFactory<MyCustomConnectionFactory>();","title":"Additional Considerations"},{"location":"CustomDatabaseConnections/Overview.html#sample-code","text":"A sample of how to replace the connection factory can be found on our GitHub in the CustomDatabaseConnection project. Remember to fill in the CustomConnectionFactoryConnectionString connection string and the license key in appSettings.json .","title":"Sample code"},{"location":"CustomIdentity/FullOverride.html","text":"TODO Update for OpenIddict Using Your Own Custom Identity Store Samples of the below code can be found on our GitHub For this part of the documentation the code in Base Installation project will be considered the \"Before\". Getting Started - Using the Rsk.CustomIdentity Interfaces The Rsk.CustomIdentity package contains the required modal and store interfaces required to build an AdminUI compatible Identity store. Models: - ISSOUser - ISSOClaimType - ISSORole Store interfaces: - ISSOUserStore - ISSOClaimTypeStore - ISSORoleStore An implementation of ISSOStoreFactory is also required. ISSOStoreFactory will return the concrete implementations of the ISSOUserStore , ISSORoleStore , and ISSOClaimTypeStore SSOClaimStore: public class ClaimTypeStore : ISSOClaimTypeStore { public Task<ISSOClaimType> GetClaimTypeByName(string name) { throw new NotImplementedException(); } ... SSORoleStore: public class RoleStore : ISSORoleStore { public Task<ISSORole> CreateRole(ISSORole role) { throw new NotImplementedException(); } ... SSOUserStore: public class UserStore : ISSOUserStore { public Task<ISSOUser> CreateUser(ISSOUser user) { throw new NotImplementedException(); } ... SSOStoreFactory: public class SSOStoreFactory : ISSOStoreFactory { public ISSOUserStore CreateUserStore() { return new UserStore(); } public ISSORoleStore CreateRoleStore() { return new RoleStore(); } public ISSOClaimTypeStore CreateClaimTypeStore() { return new ClaimTypeStore(); } } Once you have provided an implementation of these interfaces, you can update your the pipeline registration for AdminUI in your Program.cs or Startup.cs class to: builder.Services .AddAdminUI(options => { options.IdentityType = IdentityType.DefaultIdentity; options.MigrationOptions = MigrationOptions.All; }) .WithIdentityStore<CustomStoreFactory>(); This will register your new ISSOStoreFactory implementation as the factory to use when the AdminUI service layer requests and manages Users, Roles, and Claim Types. Additionally, you must also specify to the package that you are using a custom identity implementation. Calling WithIdentityStore will stop AdminUI from running bootstrap, if you would still like to have the default bootstrapped users and roles you can take away this call, run the application and then add it back in. The code from this section can be found here The next section will use Tenancy as an example of how to transform additional fields to claims, alongside using extra tables as dynamic provider for the Enum claim type: EfCore","title":"Full Implementation"},{"location":"CustomIdentity/FullOverride.html#todo-update-for-openiddict","text":"","title":"TODO Update for OpenIddict"},{"location":"CustomIdentity/FullOverride.html#using-your-own-custom-identity-store","text":"Samples of the below code can be found on our GitHub For this part of the documentation the code in Base Installation project will be considered the \"Before\".","title":"Using Your Own Custom Identity Store"},{"location":"CustomIdentity/FullOverride.html#getting-started-using-the-rskcustomidentity-interfaces","text":"The Rsk.CustomIdentity package contains the required modal and store interfaces required to build an AdminUI compatible Identity store. Models: - ISSOUser - ISSOClaimType - ISSORole Store interfaces: - ISSOUserStore - ISSOClaimTypeStore - ISSORoleStore An implementation of ISSOStoreFactory is also required. ISSOStoreFactory will return the concrete implementations of the ISSOUserStore , ISSORoleStore , and ISSOClaimTypeStore SSOClaimStore: public class ClaimTypeStore : ISSOClaimTypeStore { public Task<ISSOClaimType> GetClaimTypeByName(string name) { throw new NotImplementedException(); } ... SSORoleStore: public class RoleStore : ISSORoleStore { public Task<ISSORole> CreateRole(ISSORole role) { throw new NotImplementedException(); } ... SSOUserStore: public class UserStore : ISSOUserStore { public Task<ISSOUser> CreateUser(ISSOUser user) { throw new NotImplementedException(); } ... SSOStoreFactory: public class SSOStoreFactory : ISSOStoreFactory { public ISSOUserStore CreateUserStore() { return new UserStore(); } public ISSORoleStore CreateRoleStore() { return new RoleStore(); } public ISSOClaimTypeStore CreateClaimTypeStore() { return new ClaimTypeStore(); } } Once you have provided an implementation of these interfaces, you can update your the pipeline registration for AdminUI in your Program.cs or Startup.cs class to: builder.Services .AddAdminUI(options => { options.IdentityType = IdentityType.DefaultIdentity; options.MigrationOptions = MigrationOptions.All; }) .WithIdentityStore<CustomStoreFactory>(); This will register your new ISSOStoreFactory implementation as the factory to use when the AdminUI service layer requests and manages Users, Roles, and Claim Types. Additionally, you must also specify to the package that you are using a custom identity implementation. Calling WithIdentityStore will stop AdminUI from running bootstrap, if you would still like to have the default bootstrapped users and roles you can take away this call, run the application and then add it back in. The code from this section can be found here The next section will use Tenancy as an example of how to transform additional fields to claims, alongside using extra tables as dynamic provider for the Enum claim type: EfCore","title":"Getting Started - Using the Rsk.CustomIdentity Interfaces"},{"location":"CustomIdentity/NoSql.html","text":"TODO Update for OpenIddict Overview If you have a requirement to use NoSQL database providers such as MongoDB to manage your users within OpenIddict, you can leverage AdminUI's Custom Identity Store interfaces to achieve this. This document will outline the basic implementations needed to achieve this integration within MongoDB using the official MongoDB.Driver package within our solution. MongoDB Configuration For our database, you will be using a locally hosting MongoDB database. To make things easier you can place MongoDB configuration in your appsettings.json file. \"IdentityDatabase\": { \"ConnectionString\": \"mongodb://localhost:27017\", \"DatabaseName\": \"AdminUIUserStore\", \"UsersCollectionName\": \"Users\", \"RolesCollectionName\": \"Roles\", \"ClaimTypesCollectionName\": \"ClaimTypes\" }, You can also create an object to deserialize these configuration values: public class IdentityStoreDatabaseSettings { public string ConnectionString { get; set; } = null!; public string DatabaseName { get; set; } = null!; public string UsersCollectionName { get; set; } = null!; public string RolesCollectionName { get; set; } = null!; public string ClaimTypesCollectionName { get; set; } = null!; } To access this configuration object, add it to your service collection in the Program.cs class. builder.Services.Configure<IdentityStoreDatabaseSettings>(builder.Configuration.GetSection(\"IdentityDatabase\")); Implementing the entity models The first step to achieving NoSQL integration with AdminUI is to create concrete implementations of our new model interfaces found within the Rsk.CustomIdentity NuGet package. These interfaces are as follows: ISSOUser ISSORole ISSOClaim ISSOClaimType ISSOUser Implementation First, create an implementation of the ISSOUser interface. public class CustomSSOUser : ISSOUser { [BsonId] [BsonRepresentation(BsonType.ObjectId)] public string Id { get; set; } public string UserName { get; set; } public string Password { get; set; } public string Email { get; set; } public string ConcurrencyStamp { get; set; } public bool TwoFactorEnabled { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public bool IsBlocked { get; } public bool IsDeleted { get; set; } public bool LockoutEnabled { get; set; } public DateTimeOffset? LockoutEnd { get; } [BsonIgnoreIfNull] public ICollection<ISSOClaim> Claims { get; set; } = new List<ISSOClaim>(); //Not part of the ISSOUser interface. Included to make querying user roles easier. [BsonIgnoreIfNull] public ICollection<ISSORole> Roles { get; set; } = new List<ISSORole>(); } The fields contained within this interface are the foundations of a user within AdminUI. If you have any additional fields you wish to manage within AdminUI, you'll need to translate them to claims and place them in the Claims collection on the user class. There are a few MongoDB specific attributes on our CustomSSOUser class. Firstly, the [BsonId] attribute specifies the field to be used as the primary key for the object. Below the [BsonId] attribute, we have the [BsonRepresentation(BsonType.ObjectId)] attribute. This attribute is used to specify that the Id field on our object is to be seen (or represented) within MongoDB as an ObjectId type. The benefit of having the Id field represented as an ObjectId , is that we can offload the generating of unique ID's for the user object to MongoDB. The [BsonIgnoreIfNull] attribute specifies that if the Claims or Roles collections on the user object are null, serializing/deserializing shouldn't be attempted. This helps to avoid any unwanted serialization issues within the MongoDB driver. ISSORole Implementation Write an implementation of the ISSORole interface. public class CustomSSORole : ISSORole { [BsonId] [BsonRepresentation(BsonType.ObjectId)] public string Id { get; set; } public string Description { get; set; } public bool NonEditable { get; set; } public string Name { get; set; } } ISSOClaimType Implementation Now, the implementation of the ISSOClaimType interface public class CustomSSOClaimType : ISSOClaimType { [BsonId] [BsonRepresentation(BsonType.ObjectId)] public string Id { get; set; } public string Name { get; set; } public string DisplayName { get; set; } public string Description { get; set; } public bool IsRequired { get; set; } public bool IsReserved { get; set; } public SSOClaimValueType ValueType { get; set; } public string RegularExpressionValidationRule { get; set; } public string RegularExpressionValidationFailureDescription { get; set; } public bool IsUserEditable { get; set; } public ICollection<string> AllowedValues { get; set; } } ISSOClaim Implementation And finally, the implementation of the ISSOClaim interface public class CustomSSOClaim : ISSOClaim { [BsonId] public int Id { get; set; } public string ClaimType { get; set; } public string ClaimValue { get; set; } } MongoDB Driver Class Mapping You must also register the class mapping within the MongoDB driver for the implementations. To do this, update your Program.cs class with the following: BsonClassMap.RegisterClassMap<CustomSSOUser>(); BsonClassMap.RegisterClassMap<CustomSSORole>(); BsonClassMap.RegisterClassMap<CustomSSOClaim>(); BsonClassMap.RegisterClassMap<CustomSSOClaimType>(); It's not a requirement for this code to be in the Program.cs class, you could also place it in the stores. However, the registration of the class maps must be present before any calls to the database wherein deserialization would take place. Store Implementations Now you must create implementations of the stores. This will mean creating implementations of the following interfaces: ISSOUserStore ISSORoleStore ISSOClaimTypeStore This will be the stores that are called withing AdminUI's service layer and contain all the methods AdminUI needs to work. ISSOUserStore Implementation Start by implementing the ISSOUserStore . This is the largest store in terms of implemented methods. // Implementation shortened for brevity public class UserStore : ISSOUserStore { private readonly IMongoCollection<CustomSSOUser> dbUsers; private readonly PasswordHasher<CustomSSOUser> passwordHasher; public UserStore(IOptions<IdentityStoreDatabaseSettings> dbSettings) { var mongoClient = new MongoClient( dbSettings.Value.ConnectionString); var mongoDatabase = mongoClient.GetDatabase( dbSettings.Value.DatabaseName); dbUsers = mongoDatabase.GetCollection<CustomSSOUser>( dbSettings.Value.UsersCollectionName); passwordHasher = new PasswordHasher<CustomSSOUser>(); } public async Task<ISSOUser> CreateUser(ISSOUser user) { var newUser = new CustomSSOUser { UserName = user.UserName, Email = user.Email, ConcurrencyStamp = Guid.NewGuid().ToString(), TwoFactorEnabled = false, FirstName = user.FirstName, LastName = user.LastName, IsDeleted = false, LockoutEnabled = false, }; foreach (var claim in user.Claims) { newUser.Claims.Add(claim); } await dbUsers.InsertOneAsync(newUser); var createdUserQuery = await dbUsers.FindAsync(u => u.UserName == newUser.UserName); return await createdUserQuery.FirstOrDefaultAsync(); } You can see how to initialise the dbUsers collection using the injected IdentityStoreDatabaseSettings configured in the Program.cs file. In production, you may want to use a factory to abstract out this functionality. ISSORoleStore Implementation Next, implement the ISSORoleStore . //Implementation shortened for brevity public class RoleStore : ISSORoleStore { private readonly IMongoCollection<CustomSSOUser> dbUsers; private readonly IMongoCollection<CustomSSORole> dbRoles; public RoleStore(IOptions<IdentityStoreDatabaseSettings> dbSettings) { var mongoClient = new MongoClient( dbSettings.Value.ConnectionString); var mongoDatabase = mongoClient.GetDatabase( dbSettings.Value.DatabaseName); dbUsers = mongoDatabase.GetCollection<CustomSSOUser>( dbSettings.Value.UsersCollectionName); dbRoles = mongoDatabase.GetCollection<CustomSSORole>( dbSettings.Value.RolesCollectionName); } public async Task<ISSORole> CreateRole(ISSORole role) { await dbRoles.InsertOneAsync(new CustomSSORole { Name = role.Name, Description = role.Description, NonEditable = role.NonEditable }); var rolesInsertedName = await dbRoles.FindAsync(r => r.Name == role.Name); return await rolesInsertedName.FirstOrDefaultAsync(); } ISSOClaimTypeStore Implementation Finally, implement the ISSOClaimTypeStore //Implementation shortened for brevity public class ClaimTypeStore : ISSOClaimTypeStore { private readonly IMongoCollection<CustomSSOClaimType> dbClaimTypes; public ClaimTypeStore(IOptions<IdentityStoreDatabaseSettings> dbSettings) { var mongoClient = new MongoClient( dbSettings.Value.ConnectionString); var mongoDatabase = mongoClient.GetDatabase( dbSettings.Value.DatabaseName); dbClaimTypes = mongoDatabase.GetCollection<CustomSSOClaimType>( dbSettings.Value.ClaimTypesCollectionName); } public async Task<ISSOClaimType> CreateClaimType(ISSOClaimType claimType) { var newClaimType = new CustomSSOClaimType { Name = claimType.Name, DisplayName = claimType.DisplayName, Description = claimType.Description, IsRequired = claimType.IsRequired, IsReserved = claimType.IsReserved, ValueType = claimType.ValueType, RegularExpressionValidationRule = claimType.RegularExpressionValidationRule, RegularExpressionValidationFailureDescription = claimType.RegularExpressionValidationFailureDescription, IsUserEditable = claimType.IsUserEditable, AllowedValues = claimType.AllowedValues }; await dbClaimTypes.InsertOneAsync(newClaimType); var claimTypeQuery = await dbClaimTypes.FindAsync(ct => ct.Name == claimType.Name); return await claimTypeQuery.FirstOrDefaultAsync(); } ISSOStoreFactory Implementation Next, you will create an implementation of the ISSOStoreFactory . This is the factory used by the AdminUI service layer to create the instances of the stores you have already written. public class CustomSSOStoreFactory : ISSOStoreFactory { private readonly IOptions<IdentityStoreDatabaseSettings> dbSettings; public CustomSSOStoreFactory(IOptions<IdentityStoreDatabaseSettings> dbSettings) { this.dbSettings = dbSettings ?? throw new ArgumentNullException(nameof(dbSettings)); } public ISSOUserStore CreateUserStore() { return new UserStore(dbSettings); } public ISSORoleStore CreateRoleStore() { return new RoleStore(dbSettings); } public ISSOClaimTypeStore CreateClaimTypeStore() { return new ClaimTypeStore(dbSettings); } } Summary In this document you have created a NoSQL implementation of an Identity Store for AdminUI using the Rsk.CustomIdentity and MongoDB.Driver NuGet packages. The full source code for this sample can be found on our GitHub page","title":"NoSql Implementation (MongoDB)"},{"location":"CustomIdentity/NoSql.html#todo-update-for-openiddict","text":"","title":"TODO Update for OpenIddict"},{"location":"CustomIdentity/NoSql.html#overview","text":"If you have a requirement to use NoSQL database providers such as MongoDB to manage your users within OpenIddict, you can leverage AdminUI's Custom Identity Store interfaces to achieve this. This document will outline the basic implementations needed to achieve this integration within MongoDB using the official MongoDB.Driver package within our solution.","title":"Overview"},{"location":"CustomIdentity/NoSql.html#mongodb-configuration","text":"For our database, you will be using a locally hosting MongoDB database. To make things easier you can place MongoDB configuration in your appsettings.json file. \"IdentityDatabase\": { \"ConnectionString\": \"mongodb://localhost:27017\", \"DatabaseName\": \"AdminUIUserStore\", \"UsersCollectionName\": \"Users\", \"RolesCollectionName\": \"Roles\", \"ClaimTypesCollectionName\": \"ClaimTypes\" }, You can also create an object to deserialize these configuration values: public class IdentityStoreDatabaseSettings { public string ConnectionString { get; set; } = null!; public string DatabaseName { get; set; } = null!; public string UsersCollectionName { get; set; } = null!; public string RolesCollectionName { get; set; } = null!; public string ClaimTypesCollectionName { get; set; } = null!; } To access this configuration object, add it to your service collection in the Program.cs class. builder.Services.Configure<IdentityStoreDatabaseSettings>(builder.Configuration.GetSection(\"IdentityDatabase\"));","title":"MongoDB Configuration"},{"location":"CustomIdentity/NoSql.html#implementing-the-entity-models","text":"The first step to achieving NoSQL integration with AdminUI is to create concrete implementations of our new model interfaces found within the Rsk.CustomIdentity NuGet package. These interfaces are as follows: ISSOUser ISSORole ISSOClaim ISSOClaimType","title":"Implementing the entity models"},{"location":"CustomIdentity/NoSql.html#issouser-implementation","text":"First, create an implementation of the ISSOUser interface. public class CustomSSOUser : ISSOUser { [BsonId] [BsonRepresentation(BsonType.ObjectId)] public string Id { get; set; } public string UserName { get; set; } public string Password { get; set; } public string Email { get; set; } public string ConcurrencyStamp { get; set; } public bool TwoFactorEnabled { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public bool IsBlocked { get; } public bool IsDeleted { get; set; } public bool LockoutEnabled { get; set; } public DateTimeOffset? LockoutEnd { get; } [BsonIgnoreIfNull] public ICollection<ISSOClaim> Claims { get; set; } = new List<ISSOClaim>(); //Not part of the ISSOUser interface. Included to make querying user roles easier. [BsonIgnoreIfNull] public ICollection<ISSORole> Roles { get; set; } = new List<ISSORole>(); } The fields contained within this interface are the foundations of a user within AdminUI. If you have any additional fields you wish to manage within AdminUI, you'll need to translate them to claims and place them in the Claims collection on the user class. There are a few MongoDB specific attributes on our CustomSSOUser class. Firstly, the [BsonId] attribute specifies the field to be used as the primary key for the object. Below the [BsonId] attribute, we have the [BsonRepresentation(BsonType.ObjectId)] attribute. This attribute is used to specify that the Id field on our object is to be seen (or represented) within MongoDB as an ObjectId type. The benefit of having the Id field represented as an ObjectId , is that we can offload the generating of unique ID's for the user object to MongoDB. The [BsonIgnoreIfNull] attribute specifies that if the Claims or Roles collections on the user object are null, serializing/deserializing shouldn't be attempted. This helps to avoid any unwanted serialization issues within the MongoDB driver.","title":"ISSOUser Implementation"},{"location":"CustomIdentity/NoSql.html#issorole-implementation","text":"Write an implementation of the ISSORole interface. public class CustomSSORole : ISSORole { [BsonId] [BsonRepresentation(BsonType.ObjectId)] public string Id { get; set; } public string Description { get; set; } public bool NonEditable { get; set; } public string Name { get; set; } }","title":"ISSORole Implementation"},{"location":"CustomIdentity/NoSql.html#issoclaimtype-implementation","text":"Now, the implementation of the ISSOClaimType interface public class CustomSSOClaimType : ISSOClaimType { [BsonId] [BsonRepresentation(BsonType.ObjectId)] public string Id { get; set; } public string Name { get; set; } public string DisplayName { get; set; } public string Description { get; set; } public bool IsRequired { get; set; } public bool IsReserved { get; set; } public SSOClaimValueType ValueType { get; set; } public string RegularExpressionValidationRule { get; set; } public string RegularExpressionValidationFailureDescription { get; set; } public bool IsUserEditable { get; set; } public ICollection<string> AllowedValues { get; set; } }","title":"ISSOClaimType Implementation"},{"location":"CustomIdentity/NoSql.html#issoclaim-implementation","text":"And finally, the implementation of the ISSOClaim interface public class CustomSSOClaim : ISSOClaim { [BsonId] public int Id { get; set; } public string ClaimType { get; set; } public string ClaimValue { get; set; } }","title":"ISSOClaim Implementation"},{"location":"CustomIdentity/NoSql.html#mongodb-driver-class-mapping","text":"You must also register the class mapping within the MongoDB driver for the implementations. To do this, update your Program.cs class with the following: BsonClassMap.RegisterClassMap<CustomSSOUser>(); BsonClassMap.RegisterClassMap<CustomSSORole>(); BsonClassMap.RegisterClassMap<CustomSSOClaim>(); BsonClassMap.RegisterClassMap<CustomSSOClaimType>(); It's not a requirement for this code to be in the Program.cs class, you could also place it in the stores. However, the registration of the class maps must be present before any calls to the database wherein deserialization would take place.","title":"MongoDB Driver Class Mapping"},{"location":"CustomIdentity/NoSql.html#store-implementations","text":"Now you must create implementations of the stores. This will mean creating implementations of the following interfaces: ISSOUserStore ISSORoleStore ISSOClaimTypeStore This will be the stores that are called withing AdminUI's service layer and contain all the methods AdminUI needs to work.","title":"Store Implementations"},{"location":"CustomIdentity/NoSql.html#issouserstore-implementation","text":"Start by implementing the ISSOUserStore . This is the largest store in terms of implemented methods. // Implementation shortened for brevity public class UserStore : ISSOUserStore { private readonly IMongoCollection<CustomSSOUser> dbUsers; private readonly PasswordHasher<CustomSSOUser> passwordHasher; public UserStore(IOptions<IdentityStoreDatabaseSettings> dbSettings) { var mongoClient = new MongoClient( dbSettings.Value.ConnectionString); var mongoDatabase = mongoClient.GetDatabase( dbSettings.Value.DatabaseName); dbUsers = mongoDatabase.GetCollection<CustomSSOUser>( dbSettings.Value.UsersCollectionName); passwordHasher = new PasswordHasher<CustomSSOUser>(); } public async Task<ISSOUser> CreateUser(ISSOUser user) { var newUser = new CustomSSOUser { UserName = user.UserName, Email = user.Email, ConcurrencyStamp = Guid.NewGuid().ToString(), TwoFactorEnabled = false, FirstName = user.FirstName, LastName = user.LastName, IsDeleted = false, LockoutEnabled = false, }; foreach (var claim in user.Claims) { newUser.Claims.Add(claim); } await dbUsers.InsertOneAsync(newUser); var createdUserQuery = await dbUsers.FindAsync(u => u.UserName == newUser.UserName); return await createdUserQuery.FirstOrDefaultAsync(); } You can see how to initialise the dbUsers collection using the injected IdentityStoreDatabaseSettings configured in the Program.cs file. In production, you may want to use a factory to abstract out this functionality.","title":"ISSOUserStore Implementation"},{"location":"CustomIdentity/NoSql.html#issorolestore-implementation","text":"Next, implement the ISSORoleStore . //Implementation shortened for brevity public class RoleStore : ISSORoleStore { private readonly IMongoCollection<CustomSSOUser> dbUsers; private readonly IMongoCollection<CustomSSORole> dbRoles; public RoleStore(IOptions<IdentityStoreDatabaseSettings> dbSettings) { var mongoClient = new MongoClient( dbSettings.Value.ConnectionString); var mongoDatabase = mongoClient.GetDatabase( dbSettings.Value.DatabaseName); dbUsers = mongoDatabase.GetCollection<CustomSSOUser>( dbSettings.Value.UsersCollectionName); dbRoles = mongoDatabase.GetCollection<CustomSSORole>( dbSettings.Value.RolesCollectionName); } public async Task<ISSORole> CreateRole(ISSORole role) { await dbRoles.InsertOneAsync(new CustomSSORole { Name = role.Name, Description = role.Description, NonEditable = role.NonEditable }); var rolesInsertedName = await dbRoles.FindAsync(r => r.Name == role.Name); return await rolesInsertedName.FirstOrDefaultAsync(); }","title":"ISSORoleStore Implementation"},{"location":"CustomIdentity/NoSql.html#issoclaimtypestore-implementation","text":"Finally, implement the ISSOClaimTypeStore //Implementation shortened for brevity public class ClaimTypeStore : ISSOClaimTypeStore { private readonly IMongoCollection<CustomSSOClaimType> dbClaimTypes; public ClaimTypeStore(IOptions<IdentityStoreDatabaseSettings> dbSettings) { var mongoClient = new MongoClient( dbSettings.Value.ConnectionString); var mongoDatabase = mongoClient.GetDatabase( dbSettings.Value.DatabaseName); dbClaimTypes = mongoDatabase.GetCollection<CustomSSOClaimType>( dbSettings.Value.ClaimTypesCollectionName); } public async Task<ISSOClaimType> CreateClaimType(ISSOClaimType claimType) { var newClaimType = new CustomSSOClaimType { Name = claimType.Name, DisplayName = claimType.DisplayName, Description = claimType.Description, IsRequired = claimType.IsRequired, IsReserved = claimType.IsReserved, ValueType = claimType.ValueType, RegularExpressionValidationRule = claimType.RegularExpressionValidationRule, RegularExpressionValidationFailureDescription = claimType.RegularExpressionValidationFailureDescription, IsUserEditable = claimType.IsUserEditable, AllowedValues = claimType.AllowedValues }; await dbClaimTypes.InsertOneAsync(newClaimType); var claimTypeQuery = await dbClaimTypes.FindAsync(ct => ct.Name == claimType.Name); return await claimTypeQuery.FirstOrDefaultAsync(); }","title":"ISSOClaimTypeStore Implementation"},{"location":"CustomIdentity/NoSql.html#issostorefactory-implementation","text":"Next, you will create an implementation of the ISSOStoreFactory . This is the factory used by the AdminUI service layer to create the instances of the stores you have already written. public class CustomSSOStoreFactory : ISSOStoreFactory { private readonly IOptions<IdentityStoreDatabaseSettings> dbSettings; public CustomSSOStoreFactory(IOptions<IdentityStoreDatabaseSettings> dbSettings) { this.dbSettings = dbSettings ?? throw new ArgumentNullException(nameof(dbSettings)); } public ISSOUserStore CreateUserStore() { return new UserStore(dbSettings); } public ISSORoleStore CreateRoleStore() { return new RoleStore(dbSettings); } public ISSOClaimTypeStore CreateClaimTypeStore() { return new ClaimTypeStore(dbSettings); } }","title":"ISSOStoreFactory Implementation"},{"location":"CustomIdentity/NoSql.html#summary","text":"In this document you have created a NoSQL implementation of an Identity Store for AdminUI using the Rsk.CustomIdentity and MongoDB.Driver NuGet packages. The full source code for this sample can be found on our GitHub page","title":"Summary"},{"location":"CustomIdentity/Overview.html","text":"TODO Update for OpenIddict Overview This page assumes you have read the AdminUI as a NuGet package documentation area. When using the AdminUI NuGet package in your web applications, you can use the default stores, partially extend the default stores, or write your own stores. This opens up AdminUI to users who may have not been able to take advantage of it in the past. Namely: 1. Users who have Users, Roles or Claim Types that do not adhere to the default Identity schema the ability to write code that allows them to be managed via AdminUI. 2. Users that require the extension of the existing identity stores. Changes AdminUI\u2019s identity model has historically been based on the ASP.NET Identity model provided by Microsoft. This means \u201cIdentity\u201d is composed primarily of Users, Roles, Claims and their associated Claim Types. This includes using the UserManager and RoleManager provided with ASP.NET Identity AdminUI 6.3 adds a group of abstractions that allow for the decoupling from this old identity model. The group of abstractions are: ISSOUserStore \u2013 Handles CRUD operations relating to users ISSOClaimTypeStore - Handles CRUD operations relating to claim types ISSORoleStore - Handles CRUD operations relating to roles These store abstractions are initialized in AdminUI's service layer using ISSOStoreFactory . Starting point To get started, take the result of the NuGet Installation and update the service registration to the following: builder.Services.AddAdminUI().WithIdentityStore<SSOStoreFactory>(); Currently the WithIdentityStore<>() method is using the default SSOStoreFactory from the AdminUI NuGet package, which is the default factory used within AdminUI. Additional Configuration The AddAdminUI method takes in additional configuration that is used to tell AdminUI if you are using a custom store or if you want to configure the migrations that run on startup. builder.Services .AddAdminUI(options => { options.IdentityType = IdentityType.DefaultIdentity; options.MigrationOptions = MigrationOptions.All; }) .WithIdentityStore<CustomStoreFactory>(); IdentityType is a pair of enums: DefaultIdentity Select this if need any of AdminUIs identity services e.g you are not using a custom identity store or are using a partial implementation that uses any of AdminUIs identity services (IIdentityUnitOfWorkFactory etc) CustomIdentity Select this to disable the default AdminUI identity services - used for full custom identity store implementations Migration Options lets you chose what, if any, migrations run on startup: All Runs all migrations on startup IdentityOnly Runs all but the IdentityServer (Configuration and Operational) migrations Migrations: Identity, ExtendedConfiguration, Audit, Saml, WsFed and DataProtection IdentityServerOnly Runs all but the Identity migrations Migrations: Configuration, Operational, ExtendedConfiguration, Audit, Saml, WsFed and DataProtection AdminUI Runs all but the Identity and IdentityServer migrations Migrations: ExtendedConfiguration, Audit, Saml, WsFed and DataProtection None Disables all migrations Next Steps Partial Implementation Will outline how to wrap the existing stores, how to override certain calls, and how to manage additional fields on your Identity models. Full Implementation Will outline how to build your own AdminUI compatible Identity store from scratch. We also provide a MongoDB example of a full implementation.","title":"Overview"},{"location":"CustomIdentity/Overview.html#todo-update-for-openiddict","text":"","title":"TODO Update for OpenIddict"},{"location":"CustomIdentity/Overview.html#overview","text":"This page assumes you have read the AdminUI as a NuGet package documentation area. When using the AdminUI NuGet package in your web applications, you can use the default stores, partially extend the default stores, or write your own stores. This opens up AdminUI to users who may have not been able to take advantage of it in the past. Namely: 1. Users who have Users, Roles or Claim Types that do not adhere to the default Identity schema the ability to write code that allows them to be managed via AdminUI. 2. Users that require the extension of the existing identity stores.","title":"Overview"},{"location":"CustomIdentity/Overview.html#changes","text":"AdminUI\u2019s identity model has historically been based on the ASP.NET Identity model provided by Microsoft. This means \u201cIdentity\u201d is composed primarily of Users, Roles, Claims and their associated Claim Types. This includes using the UserManager and RoleManager provided with ASP.NET Identity AdminUI 6.3 adds a group of abstractions that allow for the decoupling from this old identity model. The group of abstractions are: ISSOUserStore \u2013 Handles CRUD operations relating to users ISSOClaimTypeStore - Handles CRUD operations relating to claim types ISSORoleStore - Handles CRUD operations relating to roles These store abstractions are initialized in AdminUI's service layer using ISSOStoreFactory .","title":"Changes"},{"location":"CustomIdentity/Overview.html#starting-point","text":"To get started, take the result of the NuGet Installation and update the service registration to the following: builder.Services.AddAdminUI().WithIdentityStore<SSOStoreFactory>(); Currently the WithIdentityStore<>() method is using the default SSOStoreFactory from the AdminUI NuGet package, which is the default factory used within AdminUI.","title":"Starting point"},{"location":"CustomIdentity/Overview.html#additional-configuration","text":"The AddAdminUI method takes in additional configuration that is used to tell AdminUI if you are using a custom store or if you want to configure the migrations that run on startup. builder.Services .AddAdminUI(options => { options.IdentityType = IdentityType.DefaultIdentity; options.MigrationOptions = MigrationOptions.All; }) .WithIdentityStore<CustomStoreFactory>(); IdentityType is a pair of enums: DefaultIdentity Select this if need any of AdminUIs identity services e.g you are not using a custom identity store or are using a partial implementation that uses any of AdminUIs identity services (IIdentityUnitOfWorkFactory etc) CustomIdentity Select this to disable the default AdminUI identity services - used for full custom identity store implementations Migration Options lets you chose what, if any, migrations run on startup: All Runs all migrations on startup IdentityOnly Runs all but the IdentityServer (Configuration and Operational) migrations Migrations: Identity, ExtendedConfiguration, Audit, Saml, WsFed and DataProtection IdentityServerOnly Runs all but the Identity migrations Migrations: Configuration, Operational, ExtendedConfiguration, Audit, Saml, WsFed and DataProtection AdminUI Runs all but the Identity and IdentityServer migrations Migrations: ExtendedConfiguration, Audit, Saml, WsFed and DataProtection None Disables all migrations","title":"Additional Configuration"},{"location":"CustomIdentity/Overview.html#next-steps","text":"","title":"Next Steps"},{"location":"CustomIdentity/Overview.html#partial-implementation","text":"Will outline how to wrap the existing stores, how to override certain calls, and how to manage additional fields on your Identity models.","title":"Partial Implementation"},{"location":"CustomIdentity/Overview.html#full-implementation","text":"Will outline how to build your own AdminUI compatible Identity store from scratch. We also provide a MongoDB example of a full implementation.","title":"Full Implementation"},{"location":"CustomIdentity/PartialImplementation.html","text":"TODO Update for OpenIddict Using AdminUIs base stores Samples of the below code can be found on our GitHub For this part of the documentation the code in Base Installation project will be considered the \"Before\". Extending Functionality The example functionality extension will be performed on the CreateUser method on the ISSOUserStore . For this, you must: Create a class that derives from SSOUserStore Create a factory that creates this class Overwrite the CreateUser method and include a notifier Creating a new class To start, create a new class in your project call CustomUserStore.cs Make your class extend the base class SSOUserStore Create a constructor that calls base with the required interfaces Because the AdminUI DI container has already registered the services needed to extend SSOUserStore you don't need to do any DI configuration on your side, you only need to import the correct interfaces. After these steps you will end up with a class that looks like the following: public class CustomUserStore : SSOUserStore { public CustomUserStore(IIdentityUnitOfWorkFactory factory, ILookupNormalizer normaliser, IUserQueryFactory userQueryFactory) : base(factory, normaliser, userQueryFactory) { } } To use this class instead of using the default implementation, you now need to provide an implementation of the ISSOStoreFactory that returns this implementation of the ISSOUserStore and not AdminUI's In a new file create a class called CustomIdentityFactory that implements ISSOStoreFactory In the constructor, pass in classes needed to create the new CustomUserStore and CustomIdentityFactory Override the CreateUserStore method, returning the CustomUserStore After these steps you will have a new class that looks like this: public class CustomStoreFactory : ISSOStoreFactory { private readonly IIdentityUnitOfWorkFactory _factory; private readonly ILookupNormalizer _normaliser; private readonly IUserQueryFactory _userQueryFactory; public CustomStoreFactory(IIdentityUnitOfWorkFactory factory, ILookupNormalizer normaliser, IUserQueryFactory userQueryFactory) { _factory = factory ?? throw new ArgumentNullException(nameof(factory)); _normaliser = normaliser ?? throw new ArgumentNullException(nameof(normaliser)); _userQueryFactory = userQueryFactory ?? throw new ArgumentNullException(nameof(userQueryFactory)); } public ISSOUserStore CreateUserStore() { return new CustomUserStore(_factory, _normaliser, _userQueryFactory); } public ISSORoleStore CreateRoleStore() { return new SSORoleStore(_factory, _normaliser, _userQueryFactory); } public ISSOClaimTypeStore CreateClaimTypeStore() { return new SSOClaimTypeStore(_factory, _normaliser); } } Now register this factory during pipeline initialisation. In your Program.cs or Startup.cs , update the UseAdminUI call by adding WithIdentityStore . This method accepts a type that needs to implement ISSOStoreFactory var builder = WebApplication.CreateBuilder(args); builder.Services .AddAdminUI() .WithIdentityStore<CustomStoreFactory>(); If you run the code and put a breakpoint in your CustomUserStore constructor, you can see that you are now using your own code. Now you can extend it with your own functionality Now: - Create a NotificationService interface that has a Dispatch method, create a class that inherits it and register it in the DI container - Pass it into CustomUserStore . You will also need to include it in the CustomStoreFactory constructor. - Overwrite the CreateUser method to use the notification service. Now, when AdminUI creates a user, it will also call off to the new NotificationService . public class CustomUserStore : SSOUserStore { private readonly INotificationService _notificationService; public CustomUserStore(INotificationService notificationService, IIdentityUnitOfWorkFactory factory, ILookupNormalizer normaliser, IUserQueryFactory userQueryFactory) : base(factory, normaliser, userQueryFactory) { _notificationService = notificationService ?? throw new ArgumentNullException(nameof(notificationService)); } public override Task<ISSOUser> CreateUser(ISSOUser user) { var createdUser = base.CreateUser(user); _notificationService.Dispatch(\"CreateUser\"); return createdUser; } } The finished code can be found here Overriding certain calls In this section you will create a stub service to show how you overwrite certain methods if you need your own logic surrounding a method. A good example of this is the Delete method in the ISSOUserStore . By default, AdminUI performs a 'soft' deletion when deleting a user, wherein the IsDeleted flag is set to true. However, there is functionality within the UserManager used by AdminUI to perform a hard deletion wherein a user is completely removed from the database. If you preferred a user to be completely removed during deletion: Create a class that inherits from SSOUserStore like above Overwrite Delete method Initialise an instance of the unit of work Call the HardDelete method on the UserManager public class CustomUserStore : SSOUserStore { private readonly INotificationService _notificationService; private readonly IIdentityUnitOfWorkFactory _factory; public CustomUserStore(INotificationService notificationService, IIdentityUnitOfWorkFactory factory, ILookupNormalizer normaliser, IUserQueryFactory userQueryFactory) : base(factory, normaliser, userQueryFactory) { _notificationService = notificationService ?? throw new ArgumentNullException(nameof(notificationService)); _factory = factory ?? throw new ArgumentNullException(nameof(factory)); } ... public override async Task DeleteUser(ISSOUser user) { if (user == null) { throw new ArgumentNullException(nameof(user)); } using var uow = _factory.Create(); var databaseUser = user.ToIdentityExpressUser(); await uow.UserManager.HardDeleteAsync(databaseUser); } } As a result, when AdminUI's service layer calls the Delete method on the user store, instead of the default delete functionality, your new functionality will be called and the user will be completely removed from the database.","title":"Partial Implementation"},{"location":"CustomIdentity/PartialImplementation.html#todo-update-for-openiddict","text":"","title":"TODO Update for OpenIddict"},{"location":"CustomIdentity/PartialImplementation.html#using-adminuis-base-stores","text":"Samples of the below code can be found on our GitHub For this part of the documentation the code in Base Installation project will be considered the \"Before\".","title":"Using AdminUIs base stores"},{"location":"CustomIdentity/PartialImplementation.html#extending-functionality","text":"The example functionality extension will be performed on the CreateUser method on the ISSOUserStore . For this, you must: Create a class that derives from SSOUserStore Create a factory that creates this class Overwrite the CreateUser method and include a notifier","title":"Extending Functionality"},{"location":"CustomIdentity/PartialImplementation.html#creating-a-new-class","text":"To start, create a new class in your project call CustomUserStore.cs Make your class extend the base class SSOUserStore Create a constructor that calls base with the required interfaces Because the AdminUI DI container has already registered the services needed to extend SSOUserStore you don't need to do any DI configuration on your side, you only need to import the correct interfaces. After these steps you will end up with a class that looks like the following: public class CustomUserStore : SSOUserStore { public CustomUserStore(IIdentityUnitOfWorkFactory factory, ILookupNormalizer normaliser, IUserQueryFactory userQueryFactory) : base(factory, normaliser, userQueryFactory) { } } To use this class instead of using the default implementation, you now need to provide an implementation of the ISSOStoreFactory that returns this implementation of the ISSOUserStore and not AdminUI's In a new file create a class called CustomIdentityFactory that implements ISSOStoreFactory In the constructor, pass in classes needed to create the new CustomUserStore and CustomIdentityFactory Override the CreateUserStore method, returning the CustomUserStore After these steps you will have a new class that looks like this: public class CustomStoreFactory : ISSOStoreFactory { private readonly IIdentityUnitOfWorkFactory _factory; private readonly ILookupNormalizer _normaliser; private readonly IUserQueryFactory _userQueryFactory; public CustomStoreFactory(IIdentityUnitOfWorkFactory factory, ILookupNormalizer normaliser, IUserQueryFactory userQueryFactory) { _factory = factory ?? throw new ArgumentNullException(nameof(factory)); _normaliser = normaliser ?? throw new ArgumentNullException(nameof(normaliser)); _userQueryFactory = userQueryFactory ?? throw new ArgumentNullException(nameof(userQueryFactory)); } public ISSOUserStore CreateUserStore() { return new CustomUserStore(_factory, _normaliser, _userQueryFactory); } public ISSORoleStore CreateRoleStore() { return new SSORoleStore(_factory, _normaliser, _userQueryFactory); } public ISSOClaimTypeStore CreateClaimTypeStore() { return new SSOClaimTypeStore(_factory, _normaliser); } } Now register this factory during pipeline initialisation. In your Program.cs or Startup.cs , update the UseAdminUI call by adding WithIdentityStore . This method accepts a type that needs to implement ISSOStoreFactory var builder = WebApplication.CreateBuilder(args); builder.Services .AddAdminUI() .WithIdentityStore<CustomStoreFactory>(); If you run the code and put a breakpoint in your CustomUserStore constructor, you can see that you are now using your own code. Now you can extend it with your own functionality Now: - Create a NotificationService interface that has a Dispatch method, create a class that inherits it and register it in the DI container - Pass it into CustomUserStore . You will also need to include it in the CustomStoreFactory constructor. - Overwrite the CreateUser method to use the notification service. Now, when AdminUI creates a user, it will also call off to the new NotificationService . public class CustomUserStore : SSOUserStore { private readonly INotificationService _notificationService; public CustomUserStore(INotificationService notificationService, IIdentityUnitOfWorkFactory factory, ILookupNormalizer normaliser, IUserQueryFactory userQueryFactory) : base(factory, normaliser, userQueryFactory) { _notificationService = notificationService ?? throw new ArgumentNullException(nameof(notificationService)); } public override Task<ISSOUser> CreateUser(ISSOUser user) { var createdUser = base.CreateUser(user); _notificationService.Dispatch(\"CreateUser\"); return createdUser; } } The finished code can be found here","title":"Creating a new class"},{"location":"CustomIdentity/PartialImplementation.html#overriding-certain-calls","text":"In this section you will create a stub service to show how you overwrite certain methods if you need your own logic surrounding a method. A good example of this is the Delete method in the ISSOUserStore . By default, AdminUI performs a 'soft' deletion when deleting a user, wherein the IsDeleted flag is set to true. However, there is functionality within the UserManager used by AdminUI to perform a hard deletion wherein a user is completely removed from the database. If you preferred a user to be completely removed during deletion: Create a class that inherits from SSOUserStore like above Overwrite Delete method Initialise an instance of the unit of work Call the HardDelete method on the UserManager public class CustomUserStore : SSOUserStore { private readonly INotificationService _notificationService; private readonly IIdentityUnitOfWorkFactory _factory; public CustomUserStore(INotificationService notificationService, IIdentityUnitOfWorkFactory factory, ILookupNormalizer normaliser, IUserQueryFactory userQueryFactory) : base(factory, normaliser, userQueryFactory) { _notificationService = notificationService ?? throw new ArgumentNullException(nameof(notificationService)); _factory = factory ?? throw new ArgumentNullException(nameof(factory)); } ... public override async Task DeleteUser(ISSOUser user) { if (user == null) { throw new ArgumentNullException(nameof(user)); } using var uow = _factory.Create(); var databaseUser = user.ToIdentityExpressUser(); await uow.UserManager.HardDeleteAsync(databaseUser); } } As a result, when AdminUI's service layer calls the Delete method on the user store, instead of the default delete functionality, your new functionality will be called and the user will be completely removed from the database.","title":"Overriding certain calls"},{"location":"CustomIdentity/TenancyWithEF.html","text":"TODO Update for OpenIddict This section uses the code from full override as a starting point. You can find the finished code on our GitHub we recommend reading the previous section to understand the code written so far. Tenancy Example using Entity Framework In this documentation you will be learning how to make a non-AdminUI field (one that is not on ISSOUser) editable within AdminUI using claims. The outcome of this documentation is to take an example user like the one below - one that has TenantName on it which is linked to the tenants table (fig2) And make them editable in AdminUI by using claims: Prerequisites There are 3 NuGet packages and a few external dependencies before you get started Nuget Packages EntityFramework EntityFramework.SqlServer EntityFramework.Design A SqlServer database An IdentityServer that can access your user store to login Database First you must create a database model and be able to scaffold and seed a database with some sample data to get AdminUI. In this section you'll be using EntityFramework to do so. Models To get started you will create the models that represent your Identity model: Tenant User TenantUser is the model that will represent users in your system. This model is based off of ISSOUser but does not implement all of the interface. This is for 2 reasons: We want to include the roles a user belongs to in the model The claims collection needs a concrete type for Entity Framework to work against and ISSOUser expects a collection of ISSOClaim public class TenantUser { [Key] public string UserId { get; set; } public string UserName { get; set; } public string Email { get; set; } [ConcurrencyCheck] public string ConcurrencyStamp { get; set; } public bool TwoFactorEnabled { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public bool IsBlocked { get; } public bool IsDeleted { get; set; } public bool LockoutEnabled { get; set; } public DateTimeOffset? LockoutEnd { get; } public string Password { get; set; } public virtual ICollection<TenantRole> Roles { get; set; } public virtual ICollection<TenantClaim> Claims { get; set; } public virtual Tenant? Tenant { get; set; } } Tenant Role Describes roles that a user can belong to - including the Users collection on this allows EF to create a many-many connection between the Users and Roles tables. public class TenantRole : ISSORole { [Key] public string Id { get; set; } public string Description { get; set; } public bool NonEditable { get; set; } public string Name { get; set; } public virtual ICollection<TenantUser> Users { get; set; } } Tenant Claim Describes claims that a user has public class TenantClaim : ISSOClaim { [Key] public int Id { get; set; } public string ClaimType { get; set; } public string ClaimValue { get; set; } } Tenant The table representing tenants a user can belong to public class Tenant { [Key] public string Name { get; set; } } Tenant ClaimType ClaimTypes represent the ClaimType field on a TenantClaim . The main thing to note is your AllowedValues collection - this is how we will translate the Tenant table to a selectable list of values public class TenantClaimType { [Key] public string Id { get; set; } public string Name { get; set; } public string DisplayName { get; set; } public string Description { get; set; } public bool IsRequired { get; set; } public bool IsReserved { get; set; } public SSOClaimValueType ValueType { get; set; } public string RegularExpressionValidationRule { get; set; } public string RegularExpressionValidationFailureDescription { get; set; } public bool IsUserEditable { get; set; } public ICollection<TenantEnumClaimTypeValue> AllowedValues { get; set; } } Tenant Enum Claim Type Allowed Values This table ties allowed values to particular claim types. public class TenantEnumClaimTypeValue { public string ClaimTypeId { get; set; } public string Value { get; set; } } Create DBContext for Identity Your next step is to build a DbContext - a DbContext in EntityFramework is the primary class for interacting with your database, it has knowledge of all your tables and the relationships between them. As you're using Entity Framework to build the database (known as Code-First Entity Framework) you can let the models define most of the relationships, however a limitation in EntityFramework is that you cannot define composite keys at the model level, so you need to add an \"OnModelCreating\" override that defines the TenantEnumClaimTypeValue as a composite key of the claimType it belongs to and it's value public class CustomIdentityDb : DbContext { public CustomIdentityDb(DbContextOptions<CustomIdentityDb> options) : base(options){} protected override void OnModelCreating(ModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder); modelBuilder.Entity<TenantEnumClaimTypeValue>(enumClaimTypeValue => { enumClaimTypeValue.HasKey(ctv => new { ctv.ClaimTypeId, ctv.Value }); }); } public DbSet<TenantUser> Users { get; set; } public DbSet<TenantRole> Roles { get; set; } public DbSet<TenantClaim> UserClaims { get; set; } public DbSet<TenantClaimType> ClaimTypes { get; set; } public DbSet<TenantEnumClaimTypeValue> EnumClaimTypeAllowedValues { get; set; } public DbSet<Tenant> Tenants { get; set; } } Creating and Running Migrations Now that your database has been defined in code, you'll need to get it up and running. To do this, the Entity Framework tooling needs to know where your database in and what database engine to use. So in your startup register the DbContext with .AddDbContext and use the OptionsBuilder to register a SqlServer database. builder.Services.AddDbContext<CustomIdentityDb>(options => { options.UseSqlServer(@\"Server=localhost,1433;User Id=sa;Password=Password123!;Database=CustomIdentityDb;\"); }); In our sample the connection string is hardcoded for ease but it is also possible to get it from config if you please. From a terminal or command line, navigate to your project and run the following dotnet ef migrations add InitialCreate - This is what creates the migrations. After this command is run you will have a new Migrations folder in your project. Secondly run dotnet ef database update - This command connects your project to the database server and uses the migrations previously generated to generate a database. Afterwards you can navigate to your database to confirm that it has been created successfully. Seeding the database Provided in the Program.cs of our sample solution is a commented out block of code to seed the database which does the following: Maps an HttpGet to the base path Injects the new DbContext you just created Creates an Admin role Creates 2 Tenants, Assigns the Admin Role and 1 Tenant to a new User - this is the use you will use to login to AdminUI It then creates a ClaimType that represents tenants. An important note is that this code does not populate the allowed values here as you will be filling that collection at a later time It is also required, meaning we will see it when editing user details and it is reserved, meaning no one can edit it from within AdminUI. If you would like to use the code snippet, put it above the app.Run call, comment out the app.useAdminUI call, uncomment the seed block and run your solution. Updating the stores & factory The next step is to write your services to inject your context so they can make database calls. You will also need to update your factory to As an example the User store will now look like: public class UserStore : ISSOUserStore { private readonly CustomIdentityDb _identityContext; public UserStore(CustomIdentityDb identityContext) { _identityContext = identityContext ?? throw new ArgumentNullException(nameof(identityContext)); } ... and the factory: public class CustomSSOStoreFactory : ISSOStoreFactory { private readonly CustomIdentityDb _identityDb; public CustomSSOStoreFactory(CustomIdentityDb identityDb) { _identityDb = identityDb ?? throw new ArgumentNullException(nameof(identityDb)); } public ISSOUserStore CreateUserStore() { return new UserStore(_identityDb); } ... Mapping the Tenancy field Now you will write the stores so they can make the conversion from field to claim happen. As a brief behind the scenes explanation when AdminUI gets a User it will get a list of claims for that user. This is a ClaimType-ClaimValue pair. AdminUI will then get all ClaimTypes and match that Claim's ClaimType to a ClaimType's Name The rest of the guide will not take you over all of the store methods, but the essential ones crucial to the process described above, starting with getting the Claim Types. ClaimType Store The main method to focus on in the ClaimType store is the GetAllClaimTypes method. This method: Gets all ClaimTypes from the database and maps them to our store level objects (something which implements ISSOClaimType) Finds the claim type that represents Tenant (This was added upon seed) Populates the Allowed Values collection on that object by calling off to the Tenants table and getting all the names from that table Returns the ClaimTypes public async Task<IEnumerable<ISSOClaimType>> GetAllClaimTypes() { var ctList = _identityContext.ClaimTypes.Include(claimType => claimType.AllowedValues) .Select(dbCt => dbCt.ToStoreClaimType()); var tenantCt = await ctList.FirstOrDefaultAsync(ctList => ctList.Id == TenantClaimTypeConsts.TenantCTId); tenantCt.AllowedValues = _identityContext.Tenants.Select(x => x.Name).ToList(); return await ctList.ToListAsync(); } User Store When Creating or Updating a user you must map the ClaimType that you received from the ClaimStore back from a Claim on the User to a field, for example your create should do the following: Map the incoming user to something that database can read Hash password if needed Grab the value of the Tenant claim from the passed in user Validate that the claim value matches a value in the tenants table Updates the users tenants field with that value Add, Saves and Returns C# public async Task<ISSOUser> CreateUserWithPassword(ISSOUser user, string password) { var dbUser = user.ToDbUser(); dbUser.ConcurrencyStamp = Guid.NewGuid().ToString(); dbUser.Password = _passwordHasher.HashPassword(dbUser, password); var tenantName = user.Claims.FirstOrDefault(claim => claim.ClaimType == TenantClaimTypeConsts.TenantCTName)?.ClaimValue; dbUser.Tenant = await _identityContext.Tenants.FirstOrDefaultAsync(tenant => tenant.Name == tenantName); _identityContext.Users.Add(dbUser); await _identityContext.SaveChangesAsync(); var userInDb = await _identityContext.Users.FirstOrDefaultAsync(dbUsers => dbUsers.UserName == user.UserName); return userInDb.ToStoreUser(); } C# public async Task<ISSOUser> UpdateUser(ISSOUser user) { var dbUser = await _identityContext.Users.Include(dbUser => dbUser.Claims).Include(dbUser => dbUser.Roles).Include(dbUser => dbUser.Tenant).FirstOrDefaultAsync(dbUser => dbUser.UserId == user.Id); dbUser.Email = user.Email; dbUser.FirstName = user.FirstName; dbUser.UserName = user.UserName; dbUser.TwoFactorEnabled = user.TwoFactorEnabled; dbUser.LastName = user.LastName; dbUser.ConcurrencyStamp = Guid.NewGuid().ToString(); var tenantClaim = user.Claims.FirstOrDefault(userClaim => userClaim.ClaimType == TenantClaimTypeConsts.TenantCTName)?.ClaimValue; var dbTenant = _identityContext.Tenants.FirstOrDefault(tenant => tenant.Name == tenantClaim); dbUser.Tenant = dbTenant; await _identityContext.SaveChangesAsync(); return dbUser.ToStoreUser(); } Then implement the UserStores Find methods such that when the ClaimType is encountered, you map the Tenant field to a new Claim that has the TenantClaimType as the ClaimType. For example the FindUserById method looks like this: public async Task<ISSOUser> FindUserById(string userId) { var dbUser = await _identityContext.Users.Include(user => user.Claims).Include(user => user.Roles).Include(user => user.Tenant).FirstOrDefaultAsync(user => user.UserId == userId); if (dbUser == null) { throw new UserNotFoundException(userId); } var storeUser = dbUser.ToStoreUser(); storeUser.Claims.Add(new SSOClaim(TenantClaimTypeConsts.TenantCTName, dbUser.Tenant.Name)); return storeUser; } IdentityServer Setup Your IdentityServer setup might not need changing but if you are starting from the Samples you will need to add a profile service like below public class TenantProfileService : IProfileService { private readonly CustomIdentityDb _dbContext; public TenantProfileService(CustomIdentityDb dbContext) { _dbContext = dbContext; } public async Task GetProfileDataAsync(ProfileDataRequestContext context) { var userId = context.Subject.FindFirstValue(JwtClaimTypes.Subject); var user = await _dbContext.Users.Include(user => user.Roles).FirstOrDefaultAsync(tenantUser => tenantUser.UserId == userId); if (!string.IsNullOrWhiteSpace(user?.UserName)) { context.IssuedClaims.Add(new Claim(\"name\", user.UserName)); } var userRoles = user.Roles; foreach (var role in userRoles) { context.IssuedClaims.Add(new Claim(\"role\", role.Name)); } } public Task IsActiveAsync(IsActiveContext context) { context.IsActive = true; return Task.CompletedTask; } }","title":"Tenancy With Entity Framework"},{"location":"CustomIdentity/TenancyWithEF.html#todo-update-for-openiddict","text":"This section uses the code from full override as a starting point. You can find the finished code on our GitHub we recommend reading the previous section to understand the code written so far.","title":"TODO Update for OpenIddict"},{"location":"CustomIdentity/TenancyWithEF.html#tenancy-example-using-entity-framework","text":"In this documentation you will be learning how to make a non-AdminUI field (one that is not on ISSOUser) editable within AdminUI using claims. The outcome of this documentation is to take an example user like the one below - one that has TenantName on it which is linked to the tenants table (fig2) And make them editable in AdminUI by using claims:","title":"Tenancy Example using Entity Framework"},{"location":"CustomIdentity/TenancyWithEF.html#prerequisites","text":"There are 3 NuGet packages and a few external dependencies before you get started Nuget Packages EntityFramework EntityFramework.SqlServer EntityFramework.Design A SqlServer database An IdentityServer that can access your user store to login","title":"Prerequisites"},{"location":"CustomIdentity/TenancyWithEF.html#database","text":"First you must create a database model and be able to scaffold and seed a database with some sample data to get AdminUI. In this section you'll be using EntityFramework to do so.","title":"Database"},{"location":"CustomIdentity/TenancyWithEF.html#models","text":"To get started you will create the models that represent your Identity model:","title":"Models"},{"location":"CustomIdentity/TenancyWithEF.html#tenant-user","text":"TenantUser is the model that will represent users in your system. This model is based off of ISSOUser but does not implement all of the interface. This is for 2 reasons: We want to include the roles a user belongs to in the model The claims collection needs a concrete type for Entity Framework to work against and ISSOUser expects a collection of ISSOClaim public class TenantUser { [Key] public string UserId { get; set; } public string UserName { get; set; } public string Email { get; set; } [ConcurrencyCheck] public string ConcurrencyStamp { get; set; } public bool TwoFactorEnabled { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public bool IsBlocked { get; } public bool IsDeleted { get; set; } public bool LockoutEnabled { get; set; } public DateTimeOffset? LockoutEnd { get; } public string Password { get; set; } public virtual ICollection<TenantRole> Roles { get; set; } public virtual ICollection<TenantClaim> Claims { get; set; } public virtual Tenant? Tenant { get; set; } }","title":"Tenant User"},{"location":"CustomIdentity/TenancyWithEF.html#tenant-role","text":"Describes roles that a user can belong to - including the Users collection on this allows EF to create a many-many connection between the Users and Roles tables. public class TenantRole : ISSORole { [Key] public string Id { get; set; } public string Description { get; set; } public bool NonEditable { get; set; } public string Name { get; set; } public virtual ICollection<TenantUser> Users { get; set; } }","title":"Tenant Role"},{"location":"CustomIdentity/TenancyWithEF.html#tenant-claim","text":"Describes claims that a user has public class TenantClaim : ISSOClaim { [Key] public int Id { get; set; } public string ClaimType { get; set; } public string ClaimValue { get; set; } }","title":"Tenant Claim"},{"location":"CustomIdentity/TenancyWithEF.html#tenant","text":"The table representing tenants a user can belong to public class Tenant { [Key] public string Name { get; set; } }","title":"Tenant"},{"location":"CustomIdentity/TenancyWithEF.html#tenant-claimtype","text":"ClaimTypes represent the ClaimType field on a TenantClaim . The main thing to note is your AllowedValues collection - this is how we will translate the Tenant table to a selectable list of values public class TenantClaimType { [Key] public string Id { get; set; } public string Name { get; set; } public string DisplayName { get; set; } public string Description { get; set; } public bool IsRequired { get; set; } public bool IsReserved { get; set; } public SSOClaimValueType ValueType { get; set; } public string RegularExpressionValidationRule { get; set; } public string RegularExpressionValidationFailureDescription { get; set; } public bool IsUserEditable { get; set; } public ICollection<TenantEnumClaimTypeValue> AllowedValues { get; set; } }","title":"Tenant ClaimType"},{"location":"CustomIdentity/TenancyWithEF.html#tenant-enum-claim-type-allowed-values","text":"This table ties allowed values to particular claim types. public class TenantEnumClaimTypeValue { public string ClaimTypeId { get; set; } public string Value { get; set; } }","title":"Tenant Enum Claim Type Allowed Values"},{"location":"CustomIdentity/TenancyWithEF.html#create-dbcontext-for-identity","text":"Your next step is to build a DbContext - a DbContext in EntityFramework is the primary class for interacting with your database, it has knowledge of all your tables and the relationships between them. As you're using Entity Framework to build the database (known as Code-First Entity Framework) you can let the models define most of the relationships, however a limitation in EntityFramework is that you cannot define composite keys at the model level, so you need to add an \"OnModelCreating\" override that defines the TenantEnumClaimTypeValue as a composite key of the claimType it belongs to and it's value public class CustomIdentityDb : DbContext { public CustomIdentityDb(DbContextOptions<CustomIdentityDb> options) : base(options){} protected override void OnModelCreating(ModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder); modelBuilder.Entity<TenantEnumClaimTypeValue>(enumClaimTypeValue => { enumClaimTypeValue.HasKey(ctv => new { ctv.ClaimTypeId, ctv.Value }); }); } public DbSet<TenantUser> Users { get; set; } public DbSet<TenantRole> Roles { get; set; } public DbSet<TenantClaim> UserClaims { get; set; } public DbSet<TenantClaimType> ClaimTypes { get; set; } public DbSet<TenantEnumClaimTypeValue> EnumClaimTypeAllowedValues { get; set; } public DbSet<Tenant> Tenants { get; set; } }","title":"Create DBContext for Identity"},{"location":"CustomIdentity/TenancyWithEF.html#creating-and-running-migrations","text":"Now that your database has been defined in code, you'll need to get it up and running. To do this, the Entity Framework tooling needs to know where your database in and what database engine to use. So in your startup register the DbContext with .AddDbContext and use the OptionsBuilder to register a SqlServer database. builder.Services.AddDbContext<CustomIdentityDb>(options => { options.UseSqlServer(@\"Server=localhost,1433;User Id=sa;Password=Password123!;Database=CustomIdentityDb;\"); }); In our sample the connection string is hardcoded for ease but it is also possible to get it from config if you please. From a terminal or command line, navigate to your project and run the following dotnet ef migrations add InitialCreate - This is what creates the migrations. After this command is run you will have a new Migrations folder in your project. Secondly run dotnet ef database update - This command connects your project to the database server and uses the migrations previously generated to generate a database. Afterwards you can navigate to your database to confirm that it has been created successfully.","title":"Creating and Running Migrations"},{"location":"CustomIdentity/TenancyWithEF.html#seeding-the-database","text":"Provided in the Program.cs of our sample solution is a commented out block of code to seed the database which does the following: Maps an HttpGet to the base path Injects the new DbContext you just created Creates an Admin role Creates 2 Tenants, Assigns the Admin Role and 1 Tenant to a new User - this is the use you will use to login to AdminUI It then creates a ClaimType that represents tenants. An important note is that this code does not populate the allowed values here as you will be filling that collection at a later time It is also required, meaning we will see it when editing user details and it is reserved, meaning no one can edit it from within AdminUI. If you would like to use the code snippet, put it above the app.Run call, comment out the app.useAdminUI call, uncomment the seed block and run your solution.","title":"Seeding the database"},{"location":"CustomIdentity/TenancyWithEF.html#updating-the-stores-factory","text":"The next step is to write your services to inject your context so they can make database calls. You will also need to update your factory to As an example the User store will now look like: public class UserStore : ISSOUserStore { private readonly CustomIdentityDb _identityContext; public UserStore(CustomIdentityDb identityContext) { _identityContext = identityContext ?? throw new ArgumentNullException(nameof(identityContext)); } ... and the factory: public class CustomSSOStoreFactory : ISSOStoreFactory { private readonly CustomIdentityDb _identityDb; public CustomSSOStoreFactory(CustomIdentityDb identityDb) { _identityDb = identityDb ?? throw new ArgumentNullException(nameof(identityDb)); } public ISSOUserStore CreateUserStore() { return new UserStore(_identityDb); } ...","title":"Updating the stores &amp; factory"},{"location":"CustomIdentity/TenancyWithEF.html#mapping-the-tenancy-field","text":"Now you will write the stores so they can make the conversion from field to claim happen. As a brief behind the scenes explanation when AdminUI gets a User it will get a list of claims for that user. This is a ClaimType-ClaimValue pair. AdminUI will then get all ClaimTypes and match that Claim's ClaimType to a ClaimType's Name The rest of the guide will not take you over all of the store methods, but the essential ones crucial to the process described above, starting with getting the Claim Types.","title":"Mapping the Tenancy field"},{"location":"CustomIdentity/TenancyWithEF.html#claimtype-store","text":"The main method to focus on in the ClaimType store is the GetAllClaimTypes method. This method: Gets all ClaimTypes from the database and maps them to our store level objects (something which implements ISSOClaimType) Finds the claim type that represents Tenant (This was added upon seed) Populates the Allowed Values collection on that object by calling off to the Tenants table and getting all the names from that table Returns the ClaimTypes public async Task<IEnumerable<ISSOClaimType>> GetAllClaimTypes() { var ctList = _identityContext.ClaimTypes.Include(claimType => claimType.AllowedValues) .Select(dbCt => dbCt.ToStoreClaimType()); var tenantCt = await ctList.FirstOrDefaultAsync(ctList => ctList.Id == TenantClaimTypeConsts.TenantCTId); tenantCt.AllowedValues = _identityContext.Tenants.Select(x => x.Name).ToList(); return await ctList.ToListAsync(); }","title":"ClaimType Store"},{"location":"CustomIdentity/TenancyWithEF.html#user-store","text":"When Creating or Updating a user you must map the ClaimType that you received from the ClaimStore back from a Claim on the User to a field, for example your create should do the following: Map the incoming user to something that database can read Hash password if needed Grab the value of the Tenant claim from the passed in user Validate that the claim value matches a value in the tenants table Updates the users tenants field with that value Add, Saves and Returns C# public async Task<ISSOUser> CreateUserWithPassword(ISSOUser user, string password) { var dbUser = user.ToDbUser(); dbUser.ConcurrencyStamp = Guid.NewGuid().ToString(); dbUser.Password = _passwordHasher.HashPassword(dbUser, password); var tenantName = user.Claims.FirstOrDefault(claim => claim.ClaimType == TenantClaimTypeConsts.TenantCTName)?.ClaimValue; dbUser.Tenant = await _identityContext.Tenants.FirstOrDefaultAsync(tenant => tenant.Name == tenantName); _identityContext.Users.Add(dbUser); await _identityContext.SaveChangesAsync(); var userInDb = await _identityContext.Users.FirstOrDefaultAsync(dbUsers => dbUsers.UserName == user.UserName); return userInDb.ToStoreUser(); } C# public async Task<ISSOUser> UpdateUser(ISSOUser user) { var dbUser = await _identityContext.Users.Include(dbUser => dbUser.Claims).Include(dbUser => dbUser.Roles).Include(dbUser => dbUser.Tenant).FirstOrDefaultAsync(dbUser => dbUser.UserId == user.Id); dbUser.Email = user.Email; dbUser.FirstName = user.FirstName; dbUser.UserName = user.UserName; dbUser.TwoFactorEnabled = user.TwoFactorEnabled; dbUser.LastName = user.LastName; dbUser.ConcurrencyStamp = Guid.NewGuid().ToString(); var tenantClaim = user.Claims.FirstOrDefault(userClaim => userClaim.ClaimType == TenantClaimTypeConsts.TenantCTName)?.ClaimValue; var dbTenant = _identityContext.Tenants.FirstOrDefault(tenant => tenant.Name == tenantClaim); dbUser.Tenant = dbTenant; await _identityContext.SaveChangesAsync(); return dbUser.ToStoreUser(); } Then implement the UserStores Find methods such that when the ClaimType is encountered, you map the Tenant field to a new Claim that has the TenantClaimType as the ClaimType. For example the FindUserById method looks like this: public async Task<ISSOUser> FindUserById(string userId) { var dbUser = await _identityContext.Users.Include(user => user.Claims).Include(user => user.Roles).Include(user => user.Tenant).FirstOrDefaultAsync(user => user.UserId == userId); if (dbUser == null) { throw new UserNotFoundException(userId); } var storeUser = dbUser.ToStoreUser(); storeUser.Claims.Add(new SSOClaim(TenantClaimTypeConsts.TenantCTName, dbUser.Tenant.Name)); return storeUser; }","title":"User Store"},{"location":"CustomIdentity/TenancyWithEF.html#identityserver-setup","text":"Your IdentityServer setup might not need changing but if you are starting from the Samples you will need to add a profile service like below public class TenantProfileService : IProfileService { private readonly CustomIdentityDb _dbContext; public TenantProfileService(CustomIdentityDb dbContext) { _dbContext = dbContext; } public async Task GetProfileDataAsync(ProfileDataRequestContext context) { var userId = context.Subject.FindFirstValue(JwtClaimTypes.Subject); var user = await _dbContext.Users.Include(user => user.Roles).FirstOrDefaultAsync(tenantUser => tenantUser.UserId == userId); if (!string.IsNullOrWhiteSpace(user?.UserName)) { context.IssuedClaims.Add(new Claim(\"name\", user.UserName)); } var userRoles = user.Roles; foreach (var role in userRoles) { context.IssuedClaims.Add(new Claim(\"role\", role.Name)); } } public Task IsActiveAsync(IsActiveContext context) { context.IsActive = true; return Task.CompletedTask; } }","title":"IdentityServer Setup"},{"location":"FAQs/FAQs.html","text":"TODO Update for OpenIddict I am experiencing caching issues when updating AdminUI This is typically due to the index.html file being cached in the browser. Whilst AdminUI has aggressive default caching in the index.html file these settings could be overriden by certain setups. If this is the case or you need to change the defaults we recommend updating your webserver following the guidelines from the mozilla documentation . When updating/deleting a user/client/resource AdminUI is unable to perform the action and a CORS error is in the console. If you can sign in but not update users/clients/resources then you may have something blocking PUT/DELETE requests on your environment I have installed AdminUI, but it is in a foreign language. The website uses your browser culture to check what language to display. You can either change your browser language or change the route to use your preferred culture of choice: e.g: http://YourAdminUI-UI/en-GB. When running migrations I get a Create Unique Index error If you see and error similar to the following: CREATE UNIQUE INDEX statement terminated because a duplicate key was found for the object name 'dbo.ClientScopes' and the index name 'IX_ClientScopes_ClientId_Scope'. The duplicate key value is (1, admin_api). This usually occurs when trying to upgrade to an AdminUI versions from before we introduced a unique index on the ClientScopes and ApiScopes tables. The fix is to rename duplicate ApiScopes and remove duplicate entries from the ClientScopes table. I\u2019m getting a HTTP Error 500.19 - Internal Service Error when starting AdminUI. Please download and run the dotnet core hosting bundle. For those on AdminUI 6.x.x and above please use the following link: https://dotnet.microsoft.com/en-us/download/dotnet/6.0 For those on AdminUI 3.x.x to 5.x.x and above please use the following link: https://dotnet.microsoft.com/download/dotnet-core/3.1 If you are running AdminUI 2.6 and below please use the following link: https://dotnet.microsoft.com/download/dotnet-core/2.1 If this fails to work and your configuration looks correct please send us a copy of your AdminUI logs to support@openiddictcomponents.com and we will be able to help as soon as possible. When starting AdminUI I get the following message - \u201cAn unhandled exception occurred while processing the request. AggregateException: One or more errors occurred. (One or more errors occurred. (Failed to start 'npm')\u201d This is due to your ASPNETCORE_ENVIRONMENT being set to \u201cDevelopment\u201d. to change this set the ASPNETCORE_ENVIRONMENT variable to \u201cProduction\u201d Either in your appsettings.json or your web.config When running AdminUI on a path, the path is stripped from UI requests Please use the X-Forwarded-Prefix header to allow AdminUI to attach your path to the PathBase of the request. For example in nginx this would look like: location /admin/{ ... proxy_set_header X-Forwarded-Prefix /admin; ... } My license key is invalid, what do I do? Please ensure that you have only copy pasted the Base64 string. Example: eyJTb2xkRm9yIjowLjAsIktleVByZXNldCI6MSwiU2F2ZUtleSI6ZmFsc2UsIkxlZ2FjeUtleSI6ZmFsc2UsIlJlbmV3YWxTZW50VGltZSI6IjAwMDEtMDEtMDFUMDA6MDA6MDAiLCJleHAiOiIyMDIwLTA3LTMwVDAxOjAwOjAyLjgzOTIwNTIrMDE6MDAiLCJpYXQiOiIyMDIwLTA2LTMwVDAwOjAwOjAyIiwiYXVkIjoxLCJ0eXBlIjozfQ==.f6vJQUvAZeSIe+1kf9n2G664UgDcpctpET7YwGrRP+h8V2bn9TYi/NXizi2ddQYEoWCmJSk47ro6JZJLjc1wq+5Re9Eu+rJjjaPcLRkgrOLJgaGZYYQJIwHS4Obta+uYtoC7uGqyYubtqxmExh1DghYOF8wR/E3ZauRJHlKG9aObVVxXt3VecPzl4+bGOGOC0vCk07aLYxW5VE539Pfv9hFAmPaM5mgy6br7cW0PAvbVNwSnLdmFgE0CgDYcHouItd6jVHILRvD6s0CjZjEFJ1Dhu2OH3CHau3GXpSQ/Xl85GXHClorY5JbC5UcqCPpqbTyYUd7QBV0e2H0VHBNRxb8AvZ2SnacY94DiZouzbDhso9ihEy3Jt4dHvDjsW5TJ5lvFFgRBJNFajG3ZBN2pfd/4O/CgWzJw+SX0epTcE7cd31OzWBCOqE4yxYbPTANqHiweqToROaangoUUYDm6M7IhjjCDtczgLCoI5hu28ZxI7xN4NYBqKS4uWF71uw+QW3YckQSiZQOo9Nc4NJBPMVdLi8O0LwAse5RIT8ywJoFbm25r4Oat18tILn7HsIuJH7WXC8jQxwL0qEZjbuNYBAgI/UN7Yw5xTXp6evbIUNrmiTO6o7DE0QviOy89qH0BT3QrKoPdEaHH4RM+rsgiQGcd2QBjU9PS5A7NDpsRc/E= Ensure there are no additional characters before or after the license key. If your license key has expired or is setup against an AuthorityUrl you did not expect. Please contact support@openiddictcomponents.com What is the difference between a blocked user and a deleted user? How are they treated in AdminUI? The 'IsDeleted' attribute is typically employed for a soft delete, preserving user information for auditing purposes. On the other hand, 'IsBlocked' is typically utilized in scenarios where a password has been compromised, preventing login until the password is reset. In the default User Store of AdminUI, users are not deleted from the database but rather have 'IsDeleted' set to true for auditing. Consequently, these users disapear from the user list but users could still log in if your IdentityServer login conditions are not configured accordingly . The primary impact on AdminUI is that users marked with either of these attributes will not be visible in the user list. To prevent confusion, consider one of the following options: Integrate the 'IsDeleted' field into your authentication logic, disallowing login for any user marked with this attribute. Develop your custom user store and perform a hard delete on the user when the delete button is pressed (not recommended). Keep in mind that this approach will result in the loss of audit entry information related to that user. The documentation for adding a custom user store can be found here: Custom Identity Overview .","title":"FAQs"},{"location":"FAQs/FAQs.html#todo-update-for-openiddict","text":"","title":"TODO Update for OpenIddict"},{"location":"FAQs/FAQs.html#i-am-experiencing-caching-issues-when-updating-adminui","text":"This is typically due to the index.html file being cached in the browser. Whilst AdminUI has aggressive default caching in the index.html file these settings could be overriden by certain setups. If this is the case or you need to change the defaults we recommend updating your webserver following the guidelines from the mozilla documentation .","title":"I am experiencing caching issues when updating AdminUI"},{"location":"FAQs/FAQs.html#when-updatingdeleting-a-userclientresource-adminui-is-unable-to-perform-the-action-and-a-cors-error-is-in-the-console","text":"If you can sign in but not update users/clients/resources then you may have something blocking PUT/DELETE requests on your environment","title":"When updating/deleting a user/client/resource AdminUI is unable to perform the action and a CORS error is in the console."},{"location":"FAQs/FAQs.html#i-have-installed-adminui-but-it-is-in-a-foreign-language","text":"The website uses your browser culture to check what language to display. You can either change your browser language or change the route to use your preferred culture of choice: e.g: http://YourAdminUI-UI/en-GB.","title":"I have installed AdminUI, but it is in a foreign language."},{"location":"FAQs/FAQs.html#when-running-migrations-i-get-a-create-unique-index-error","text":"If you see and error similar to the following: CREATE UNIQUE INDEX statement terminated because a duplicate key was found for the object name 'dbo.ClientScopes' and the index name 'IX_ClientScopes_ClientId_Scope'. The duplicate key value is (1, admin_api). This usually occurs when trying to upgrade to an AdminUI versions from before we introduced a unique index on the ClientScopes and ApiScopes tables. The fix is to rename duplicate ApiScopes and remove duplicate entries from the ClientScopes table.","title":"When running migrations I get a Create Unique Index error"},{"location":"FAQs/FAQs.html#im-getting-a-http-error-50019-internal-service-error-when-starting-adminui","text":"Please download and run the dotnet core hosting bundle. For those on AdminUI 6.x.x and above please use the following link: https://dotnet.microsoft.com/en-us/download/dotnet/6.0 For those on AdminUI 3.x.x to 5.x.x and above please use the following link: https://dotnet.microsoft.com/download/dotnet-core/3.1 If you are running AdminUI 2.6 and below please use the following link: https://dotnet.microsoft.com/download/dotnet-core/2.1 If this fails to work and your configuration looks correct please send us a copy of your AdminUI logs to support@openiddictcomponents.com and we will be able to help as soon as possible.","title":"I\u2019m getting a HTTP Error 500.19 - Internal Service Error when starting AdminUI."},{"location":"FAQs/FAQs.html#when-starting-adminui-i-get-the-following-message-an-unhandled-exception-occurred-while-processing-the-request-aggregateexception-one-or-more-errors-occurred-one-or-more-errors-occurred-failed-to-start-npm","text":"This is due to your ASPNETCORE_ENVIRONMENT being set to \u201cDevelopment\u201d. to change this set the ASPNETCORE_ENVIRONMENT variable to \u201cProduction\u201d Either in your appsettings.json or your web.config","title":"When starting AdminUI I get the following message - \u201cAn unhandled exception occurred while processing the request. AggregateException: One or more errors occurred. (One or more errors occurred. (Failed to start 'npm')\u201d"},{"location":"FAQs/FAQs.html#when-running-adminui-on-a-path-the-path-is-stripped-from-ui-requests","text":"Please use the X-Forwarded-Prefix header to allow AdminUI to attach your path to the PathBase of the request. For example in nginx this would look like: location /admin/{ ... proxy_set_header X-Forwarded-Prefix /admin; ... }","title":"When running AdminUI on a path, the path is stripped from UI requests"},{"location":"FAQs/FAQs.html#my-license-key-is-invalid-what-do-i-do","text":"Please ensure that you have only copy pasted the Base64 string. Example: eyJTb2xkRm9yIjowLjAsIktleVByZXNldCI6MSwiU2F2ZUtleSI6ZmFsc2UsIkxlZ2FjeUtleSI6ZmFsc2UsIlJlbmV3YWxTZW50VGltZSI6IjAwMDEtMDEtMDFUMDA6MDA6MDAiLCJleHAiOiIyMDIwLTA3LTMwVDAxOjAwOjAyLjgzOTIwNTIrMDE6MDAiLCJpYXQiOiIyMDIwLTA2LTMwVDAwOjAwOjAyIiwiYXVkIjoxLCJ0eXBlIjozfQ==.f6vJQUvAZeSIe+1kf9n2G664UgDcpctpET7YwGrRP+h8V2bn9TYi/NXizi2ddQYEoWCmJSk47ro6JZJLjc1wq+5Re9Eu+rJjjaPcLRkgrOLJgaGZYYQJIwHS4Obta+uYtoC7uGqyYubtqxmExh1DghYOF8wR/E3ZauRJHlKG9aObVVxXt3VecPzl4+bGOGOC0vCk07aLYxW5VE539Pfv9hFAmPaM5mgy6br7cW0PAvbVNwSnLdmFgE0CgDYcHouItd6jVHILRvD6s0CjZjEFJ1Dhu2OH3CHau3GXpSQ/Xl85GXHClorY5JbC5UcqCPpqbTyYUd7QBV0e2H0VHBNRxb8AvZ2SnacY94DiZouzbDhso9ihEy3Jt4dHvDjsW5TJ5lvFFgRBJNFajG3ZBN2pfd/4O/CgWzJw+SX0epTcE7cd31OzWBCOqE4yxYbPTANqHiweqToROaangoUUYDm6M7IhjjCDtczgLCoI5hu28ZxI7xN4NYBqKS4uWF71uw+QW3YckQSiZQOo9Nc4NJBPMVdLi8O0LwAse5RIT8ywJoFbm25r4Oat18tILn7HsIuJH7WXC8jQxwL0qEZjbuNYBAgI/UN7Yw5xTXp6evbIUNrmiTO6o7DE0QviOy89qH0BT3QrKoPdEaHH4RM+rsgiQGcd2QBjU9PS5A7NDpsRc/E= Ensure there are no additional characters before or after the license key. If your license key has expired or is setup against an AuthorityUrl you did not expect. Please contact support@openiddictcomponents.com","title":"My license key is invalid, what do I do?"},{"location":"FAQs/FAQs.html#what-is-the-difference-between-a-blocked-user-and-a-deleted-user-how-are-they-treated-in-adminui","text":"The 'IsDeleted' attribute is typically employed for a soft delete, preserving user information for auditing purposes. On the other hand, 'IsBlocked' is typically utilized in scenarios where a password has been compromised, preventing login until the password is reset. In the default User Store of AdminUI, users are not deleted from the database but rather have 'IsDeleted' set to true for auditing. Consequently, these users disapear from the user list but users could still log in if your IdentityServer login conditions are not configured accordingly . The primary impact on AdminUI is that users marked with either of these attributes will not be visible in the user list. To prevent confusion, consider one of the following options: Integrate the 'IsDeleted' field into your authentication logic, disallowing login for any user marked with this attribute. Develop your custom user store and perform a hard delete on the user when the delete button is pressed (not recommended). Keep in mind that this approach will result in the loss of audit entry information related to that user. The documentation for adding a custom user store can be found here: Custom Identity Overview .","title":"What is the difference between a blocked user and a deleted user? How are they treated in AdminUI?"},{"location":"Installation/Installation_NuGet.html","text":"TODO Update for OpenIddict This walkthrough will run you through the basics of using AdminUI as a NuGet package. Prerequisites Before getting started you will need a AdminUI License Key which you can get from our products page . Once you have a key, you will need to download the latest version of AdminUI from our downloads page . You will also need an IdentityServer installation and either a MySql, SqlServer or PostgreSql database set up. There is a sample IdentityServer available on our GitHub . If you are going to be using the IdentityExpress.Identity schema, make sure your IdentityServer is already set up to do so. A guide on how to do this can be found here . The above step is not necessary if you are going to be using a custom identity schema. Basic Installation Samples A sample of the below steps can be found in our sample repo on GitHub From Scratch Watch this video installation guide or follow the written tutorial below. When starting from scratch we recommend you create a project from the ASP.NET Core Empty template. This can be done through the Visual Studio GUI: Or from the .NET CLI using dotnet new web with your parameters of your choice. More info can be found in the Microsoft Documentation Get the AdminUI NuGet package You can install the Rsk.AdminUI NuGet package using the .NET CLI ( dotnet add package Rsk.AdminUI ), Powershell ( Install-Package Rsk.AdminUI ), or your GUI of choice. On first build the package will copy over the relevant static files into your wwwroot folder in a new admin folder e.g: wwwwroot/admin . On run it will serve from this folder on the base path of the project (e.g http://localhost:5000/). Configuration AdminUI specific config Please read our configuration page for more info You can find sample configuration in our sample repo UI Url - The URL AdminUI is run on -AuthorityURL - The URL of your IdentityServer. IdentityConnectionString - The database connection string of your Identity database IdentityServerConnectionString - The database connection string of your IdentityServer database AdminUIClientSecret - A random secret value LicenseKey - The key you were provided with when you purchased the product or obtained a demo Configure a Database & Migrations AdminUI currently only supports MySql, PostgreSQL, SqlServer, and SqlExpress. Any database must accept remote connections. Ensure that your firewall allows connections on any used ports. Migrations will run on app start by default. To configure which migrations run or to turn off migrations completely you can use the options in AddAdminUI. e.g: builder.Services.AddAdminUI(options => { options.MigrationOptions = MigrationOptions.None; }); Using the package Register AdminUI in your service collection, then add it to your application's pipeline. using IdentityExpress.Manager.UI.Extensions; var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddAdminUI(); var app = builder.Build(); app.UseHttpsRedirection(); app.UseAdminUI(); app.Run(); Using NuGet Package with Custom Identity Store The AdminUI NuGet package can be used as the foundations of a custom identity store . This will allow you to extend AdminUI's functionality around Users, Roles, and Claim Types. Using NuGet Package with Custom Database Connections In AdminUI 6.7 the AdminUI NuGet package uses a factory abstraction for creating database connections. You can replace the default implementation by providing a custom database connection factory . This will allow you to create connections according to your own needs. Running migrations manually AdminUI 6.7 adds the ability to programmatically run migrations manually. This can be done by turning off automatic migrations and using a new extension method thus: var builder = WebApplication.CreateBuilder(args); builder.Services .AddAdminUI( options => { options.MigrationOptions = MigrationOptions.None; } ); var app = builder.Build(); app.RunMigrations(MigrationType.All); This can be done with or without a custom connection factory. The migration type is taken from the follwing enumeration: public enum MigrationType { Unknown, All, IdentityServerOnly, IdentityOnly, AdminUI, Configuration, ExtendedConfiguration, Operational, Identity, Audit, Saml, WsFed, DataProtection } Excluding Packaged UI Files If you have disabled the UI in AdminUI and wish to also not include the static web files in the the project you are using AdminUI in you can also configure the build to exclude them. This can be done with a build property in the .csproj file for you project. Here is an example to show how. If this setting is 'exclude' the static ui files are not included, else static ui files are included. <PropertyGroup> <DefaultUi>exclude</DefaultUi> </PropertyGroup>","title":"NuGet"},{"location":"Installation/Installation_NuGet.html#todo-update-for-openiddict","text":"This walkthrough will run you through the basics of using AdminUI as a NuGet package.","title":"TODO Update for OpenIddict"},{"location":"Installation/Installation_NuGet.html#prerequisites","text":"Before getting started you will need a AdminUI License Key which you can get from our products page . Once you have a key, you will need to download the latest version of AdminUI from our downloads page . You will also need an IdentityServer installation and either a MySql, SqlServer or PostgreSql database set up. There is a sample IdentityServer available on our GitHub . If you are going to be using the IdentityExpress.Identity schema, make sure your IdentityServer is already set up to do so. A guide on how to do this can be found here . The above step is not necessary if you are going to be using a custom identity schema.","title":"Prerequisites"},{"location":"Installation/Installation_NuGet.html#basic-installation","text":"","title":"Basic Installation"},{"location":"Installation/Installation_NuGet.html#samples","text":"A sample of the below steps can be found in our sample repo on GitHub","title":"Samples"},{"location":"Installation/Installation_NuGet.html#from-scratch","text":"Watch this video installation guide or follow the written tutorial below. When starting from scratch we recommend you create a project from the ASP.NET Core Empty template. This can be done through the Visual Studio GUI: Or from the .NET CLI using dotnet new web with your parameters of your choice. More info can be found in the Microsoft Documentation","title":"From Scratch"},{"location":"Installation/Installation_NuGet.html#get-the-adminui-nuget-package","text":"You can install the Rsk.AdminUI NuGet package using the .NET CLI ( dotnet add package Rsk.AdminUI ), Powershell ( Install-Package Rsk.AdminUI ), or your GUI of choice. On first build the package will copy over the relevant static files into your wwwroot folder in a new admin folder e.g: wwwwroot/admin . On run it will serve from this folder on the base path of the project (e.g http://localhost:5000/).","title":"Get the AdminUI NuGet package"},{"location":"Installation/Installation_NuGet.html#configuration","text":"","title":"Configuration"},{"location":"Installation/Installation_NuGet.html#adminui-specific-config","text":"Please read our configuration page for more info You can find sample configuration in our sample repo UI Url - The URL AdminUI is run on -AuthorityURL - The URL of your IdentityServer. IdentityConnectionString - The database connection string of your Identity database IdentityServerConnectionString - The database connection string of your IdentityServer database AdminUIClientSecret - A random secret value LicenseKey - The key you were provided with when you purchased the product or obtained a demo","title":"AdminUI specific config"},{"location":"Installation/Installation_NuGet.html#configure-a-database-migrations","text":"AdminUI currently only supports MySql, PostgreSQL, SqlServer, and SqlExpress. Any database must accept remote connections. Ensure that your firewall allows connections on any used ports. Migrations will run on app start by default. To configure which migrations run or to turn off migrations completely you can use the options in AddAdminUI. e.g: builder.Services.AddAdminUI(options => { options.MigrationOptions = MigrationOptions.None; });","title":"Configure a Database &amp; Migrations"},{"location":"Installation/Installation_NuGet.html#using-the-package","text":"Register AdminUI in your service collection, then add it to your application's pipeline. using IdentityExpress.Manager.UI.Extensions; var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddAdminUI(); var app = builder.Build(); app.UseHttpsRedirection(); app.UseAdminUI(); app.Run();","title":"Using the package"},{"location":"Installation/Installation_NuGet.html#using-nuget-package-with-custom-identity-store","text":"The AdminUI NuGet package can be used as the foundations of a custom identity store . This will allow you to extend AdminUI's functionality around Users, Roles, and Claim Types.","title":"Using NuGet Package with Custom Identity Store"},{"location":"Installation/Installation_NuGet.html#using-nuget-package-with-custom-database-connections","text":"In AdminUI 6.7 the AdminUI NuGet package uses a factory abstraction for creating database connections. You can replace the default implementation by providing a custom database connection factory . This will allow you to create connections according to your own needs.","title":"Using NuGet Package with Custom Database Connections"},{"location":"Installation/Installation_NuGet.html#running-migrations-manually","text":"AdminUI 6.7 adds the ability to programmatically run migrations manually. This can be done by turning off automatic migrations and using a new extension method thus: var builder = WebApplication.CreateBuilder(args); builder.Services .AddAdminUI( options => { options.MigrationOptions = MigrationOptions.None; } ); var app = builder.Build(); app.RunMigrations(MigrationType.All); This can be done with or without a custom connection factory. The migration type is taken from the follwing enumeration: public enum MigrationType { Unknown, All, IdentityServerOnly, IdentityOnly, AdminUI, Configuration, ExtendedConfiguration, Operational, Identity, Audit, Saml, WsFed, DataProtection }","title":"Running migrations manually"},{"location":"Installation/Installation_NuGet.html#excluding-packaged-ui-files","text":"If you have disabled the UI in AdminUI and wish to also not include the static web files in the the project you are using AdminUI in you can also configure the build to exclude them. This can be done with a build property in the .csproj file for you project. Here is an example to show how. If this setting is 'exclude' the static ui files are not included, else static ui files are included. <PropertyGroup> <DefaultUi>exclude</DefaultUi> </PropertyGroup>","title":"Excluding Packaged UI Files"},{"location":"OpenIddict/What_Is_OpenIddict.html","text":"What is OpenIddict? TODO... How does AdminUI fit in? AdminUI provides a web portal for you to administer your OpenIddict solution. TODO...","title":"What is OpenIddict"},{"location":"OpenIddict/What_Is_OpenIddict.html#what-is-openiddict","text":"TODO...","title":"What is OpenIddict?"},{"location":"OpenIddict/What_Is_OpenIddict.html#how-does-adminui-fit-in","text":"AdminUI provides a web portal for you to administer your OpenIddict solution. TODO...","title":"How does AdminUI fit in?"},{"location":"Read_First/Installation_Scenarios.html","text":"Installation Scenarios I have neither OpenIddict or AdminUI installed TODO create, I have OpenIddict X installed. TODO create,","title":"Installation Scenarios"},{"location":"Read_First/Installation_Scenarios.html#installation-scenarios","text":"","title":"Installation Scenarios"},{"location":"Read_First/Installation_Scenarios.html#i-have-neither-openiddict-or-adminui-installed","text":"","title":"I have neither OpenIddict or AdminUI installed"},{"location":"Read_First/Installation_Scenarios.html#todo-create","text":"","title":"TODO create,"},{"location":"Read_First/Installation_Scenarios.html#i-have-openiddict-x-installed","text":"","title":"I have OpenIddict X installed."},{"location":"Read_First/Installation_Scenarios.html#todo-create_1","text":"","title":"TODO create,"},{"location":"Roles/Creating_roles.html","text":"Creating Roles Roles can be created in AdminUI in order to create the roles you need within your application. By clicking \"Add Role\", we can create a new role within the AdminUI application. Selecting this button will bring up a window to enable you to add a new role. There is a simple Name and Description field, and the option to either Add directly, or Add another Role after Submit. Adding another role after submit simply shows a blank version of the New Role window. Success! If the role has been successfully added, a success dialogue will display.","title":"Creating Roles"},{"location":"Roles/Creating_roles.html#creating-roles","text":"Roles can be created in AdminUI in order to create the roles you need within your application. By clicking \"Add Role\", we can create a new role within the AdminUI application. Selecting this button will bring up a window to enable you to add a new role. There is a simple Name and Description field, and the option to either Add directly, or Add another Role after Submit. Adding another role after submit simply shows a blank version of the New Role window.","title":"Creating Roles"},{"location":"Roles/Creating_roles.html#success","text":"If the role has been successfully added, a success dialogue will display.","title":"Success!"},{"location":"Roles/Managing_Roles.html","text":"Searching for Roles Searching for Roles within Admin UI is a powerful way to quickly find and manage the Roles within the application. You can find Roles in the application in several ways, starting with the Search functionality. Start typing and the role will appear if there is a match. Editing a Role Roles can be edited within AdminUI in order to edit the roles already setup in your application. By clicking the pencil icon, an Edit dialogue will appear enabling us to customise the role within the AdminUI application. Once you have made the edits you require, click \"Save\" to persist the changes to the Role you have saved. If the changes have been saved as required, you will observe a \"Changes Saved\" dialogue appear. Deleting Roles During the Edit Roles dialogue, a Delete button option will appear. If this is clicked, you will be warned as to whether you want to permanently delete this role. You can change your mind and close the dialogue or not delete, or click \"Delete\" to proceed with this deletion.","title":"Managing Roles"},{"location":"Roles/Managing_Roles.html#searching-for-roles","text":"Searching for Roles within Admin UI is a powerful way to quickly find and manage the Roles within the application. You can find Roles in the application in several ways, starting with the Search functionality. Start typing and the role will appear if there is a match.","title":"Searching for Roles"},{"location":"Roles/Managing_Roles.html#editing-a-role","text":"Roles can be edited within AdminUI in order to edit the roles already setup in your application. By clicking the pencil icon, an Edit dialogue will appear enabling us to customise the role within the AdminUI application. Once you have made the edits you require, click \"Save\" to persist the changes to the Role you have saved. If the changes have been saved as required, you will observe a \"Changes Saved\" dialogue appear.","title":"Editing a Role"},{"location":"Roles/Managing_Roles.html#deleting-roles","text":"During the Edit Roles dialogue, a Delete button option will appear. If this is clicked, you will be warned as to whether you want to permanently delete this role. You can change your mind and close the dialogue or not delete, or click \"Delete\" to proceed with this deletion.","title":"Deleting Roles"},{"location":"Roles/Users_in_Role_Management.html","text":"Managing users in a role You can see the users associated with a role by selecting the user tab. The users in this list represent the users associated with the current role. Using the search input, you can filter the list. Using the 'Manage Users' button opens a new dialogue which allows you to perform multiple operations for associating and de-associating users from a role. Using the search input box, you can filter the list of users by their name. Removing Users Users in the current role are those who have tick when they appear in the list. To remove that user from a list, select the checkbox to uncheck the user. That user appears in the Removing list. Add Users Users who are not currently associated with a role appear in the list without the checkbox is active. To associate the user to the current role, select the checkbox, and the user appears in the Adding list. Saving Changes To save the changes select the 'Save' button","title":"Managing Users in a Role"},{"location":"Roles/Users_in_Role_Management.html#managing-users-in-a-role","text":"You can see the users associated with a role by selecting the user tab. The users in this list represent the users associated with the current role. Using the search input, you can filter the list. Using the 'Manage Users' button opens a new dialogue which allows you to perform multiple operations for associating and de-associating users from a role. Using the search input box, you can filter the list of users by their name.","title":"Managing users in a role"},{"location":"Roles/Users_in_Role_Management.html#removing-users","text":"Users in the current role are those who have tick when they appear in the list. To remove that user from a list, select the checkbox to uncheck the user. That user appears in the Removing list.","title":"Removing Users"},{"location":"Roles/Users_in_Role_Management.html#add-users","text":"Users who are not currently associated with a role appear in the list without the checkbox is active. To associate the user to the current role, select the checkbox, and the user appears in the Adding list.","title":"Add Users"},{"location":"Roles/Users_in_Role_Management.html#saving-changes","text":"To save the changes select the 'Save' button","title":"Saving Changes"},{"location":"Scopes/creating_scopes.html","text":"TODO Create,","title":"Creating Scopes"},{"location":"Scopes/creating_scopes.html#todo-create","text":"","title":"TODO Create,"},{"location":"Scopes/editing_scopes.html","text":"TODO Create,","title":"Editing Scopes"},{"location":"Scopes/editing_scopes.html#todo-create","text":"","title":"TODO Create,"},{"location":"Scopes/searching_for_scopes.html","text":"TODO Create,","title":"Searching for Scopes"},{"location":"Scopes/searching_for_scopes.html#todo-create","text":"","title":"TODO Create,"},{"location":"Troubleshooting/Unable_to_contact_API.html","text":"TODO Update If you experience the error message \u201cUnable to contact API\u201d, it means that the AdminUI backend cannot successfully communicate with the AdminUI API. To troubleshoot this issue, we recommend working through the following steps. To begin please make sure you have enabled logs for the API. To do so you can check the section on enabling logging. . These logs should contain an error detailing why the API could not be contacted. Does the Swagger UI work? You can verify that the API has been able to start-up by visiting the Swagger UI, available on the endpoint: https://<your-api-url>/swagger/index.html . Swagger UI loads The AdminUI API is running, but something is preventing the UI from contacting it. To find out why you will need to check the API logs. Swagger UI does not load The AdminUI API site has not been able to start-up. Typically when this happens you will see a web page with the following error: HTTP Error 500.30 - ANCM In-Process Start Failure Common issues include: Bootstrap issues When the bootstrap process fails at any point it will rollback to its previous state before the bootstrap ran. This is indicated in the logs by the message \"Bootstrap Failed - Rolling Back\". This usually happens when there is conflicting data in your database. If this is the case then you can check your logs for the error by going to your logs directory, if you haven't already enabled logs please see our enabling logging section. If this is the case please email us with your logs at support@openiddictcomponents.com Database connection One known problem is with SQL Express and SQL logins. When installing SQLExpress for the first time, it defaults to use Windows Authentication. This means that you can\u2019t log into any of the databases using SQL logins. To solve this problem, change this SQL Express setting to allow SQL logins. Another problem can be with improperly escaped SQL Express connection strings e.g. using 'localhost\\SQLExpress' instead of '.\\SQLExpress' would result in the same error. SqlException: A network-related or instance-specific error occurred while establishing a connection If you receive this error, the API cannot connect to the database. It may be that the connection string is invalid or that the website is unable to resolve the server name. SqlException: Login failed for user Check that the user name is correct and that the user has the correct permissions. If you receive this error, the API is not authorized to access the database. It may be that the user in the connection string is invalid or is not authorized to access the database. SqlException: A connection was successfully established with the server, but then an error occurred during the login process If you receive this error, the API is not authorized to access the database. In this case, it may be that the website user is trying to use SQL authentication (a username and password) but the database only supports Windows authentication. To resolve this, we recommend enabling SQL authentication in your database. This is often required when using SQL Server Express from IIS. Migrations SqlException Invalid object name 'AspNetClaimTypes' This means that the API is trying to connect to a user (identity) database that does not use AdminUI\u2019s database schema. AdminUI uses an extended version of the core ASP.NET Core Identity entity framework schema that provides strong typing for claim types and improved user and role searching. To resolve this, you will need to update the application currently in charge of user store migrations to use the AdminUI schema . Support If none of these steps work or you are unsure how to fix the error in the logs, please contact us at support@openiddictcomponents.com, detailing the issue you see, including any error logs.","title":"Unable to contact API"},{"location":"Troubleshooting/Unable_to_contact_API.html#todo-update","text":"If you experience the error message \u201cUnable to contact API\u201d, it means that the AdminUI backend cannot successfully communicate with the AdminUI API. To troubleshoot this issue, we recommend working through the following steps. To begin please make sure you have enabled logs for the API. To do so you can check the section on enabling logging. . These logs should contain an error detailing why the API could not be contacted.","title":"TODO Update"},{"location":"Troubleshooting/Unable_to_contact_API.html#does-the-swagger-ui-work","text":"You can verify that the API has been able to start-up by visiting the Swagger UI, available on the endpoint: https://<your-api-url>/swagger/index.html .","title":"Does the Swagger UI work?"},{"location":"Troubleshooting/Unable_to_contact_API.html#swagger-ui-loads","text":"The AdminUI API is running, but something is preventing the UI from contacting it. To find out why you will need to check the API logs.","title":"Swagger UI loads"},{"location":"Troubleshooting/Unable_to_contact_API.html#swagger-ui-does-not-load","text":"The AdminUI API site has not been able to start-up. Typically when this happens you will see a web page with the following error: HTTP Error 500.30 - ANCM In-Process Start Failure Common issues include:","title":"Swagger UI does not load"},{"location":"Troubleshooting/Unable_to_contact_API.html#bootstrap-issues","text":"When the bootstrap process fails at any point it will rollback to its previous state before the bootstrap ran. This is indicated in the logs by the message \"Bootstrap Failed - Rolling Back\". This usually happens when there is conflicting data in your database. If this is the case then you can check your logs for the error by going to your logs directory, if you haven't already enabled logs please see our enabling logging section. If this is the case please email us with your logs at support@openiddictcomponents.com","title":"Bootstrap issues"},{"location":"Troubleshooting/Unable_to_contact_API.html#database-connection","text":"One known problem is with SQL Express and SQL logins. When installing SQLExpress for the first time, it defaults to use Windows Authentication. This means that you can\u2019t log into any of the databases using SQL logins. To solve this problem, change this SQL Express setting to allow SQL logins. Another problem can be with improperly escaped SQL Express connection strings e.g. using 'localhost\\SQLExpress' instead of '.\\SQLExpress' would result in the same error. SqlException: A network-related or instance-specific error occurred while establishing a connection If you receive this error, the API cannot connect to the database. It may be that the connection string is invalid or that the website is unable to resolve the server name. SqlException: Login failed for user Check that the user name is correct and that the user has the correct permissions. If you receive this error, the API is not authorized to access the database. It may be that the user in the connection string is invalid or is not authorized to access the database. SqlException: A connection was successfully established with the server, but then an error occurred during the login process If you receive this error, the API is not authorized to access the database. In this case, it may be that the website user is trying to use SQL authentication (a username and password) but the database only supports Windows authentication. To resolve this, we recommend enabling SQL authentication in your database. This is often required when using SQL Server Express from IIS.","title":"Database connection"},{"location":"Troubleshooting/Unable_to_contact_API.html#migrations","text":"SqlException Invalid object name 'AspNetClaimTypes' This means that the API is trying to connect to a user (identity) database that does not use AdminUI\u2019s database schema. AdminUI uses an extended version of the core ASP.NET Core Identity entity framework schema that provides strong typing for claim types and improved user and role searching. To resolve this, you will need to update the application currently in charge of user store migrations to use the AdminUI schema .","title":"Migrations"},{"location":"Troubleshooting/Unable_to_contact_API.html#support","text":"If none of these steps work or you are unsure how to fix the error in the logs, please contact us at support@openiddictcomponents.com, detailing the issue you see, including any error logs.","title":"Support"},{"location":"Troubleshooting/Unable_to_contact_OpenIddict.html","text":"TODO Update If you experience the error message \u201cUnable to contact IdentityServer\u201d, it means that the AdminUI backend cannot successfully communicate with IdentityServer. To troubleshoot this issue, we recommend working through the following steps. Does the OpenID Connect discovery document work? You can verify that your IdentityServer can start-up and access your database by navigating to the OpenID Connect discovery document in your browser, available on the IdentityServer endpoint: https://<your-identity-server>/.well-known/openid-configuration . Discovery document does not load If your discovery document does not load, you may instead see an error page containing details on what went wrong. If you do not see any error details, you will need to check the IdentityServer logs . Discovery document loads If your discovery document does load, then the next step is to determine why IdentityServer denied the request. Check the IdentityServer logs Depending on your IdentityServer setup, IdentityServer will be logging failed incoming requests. To enable logging, check out our logging documentation . If you are using your own IdentityServer, we recommend following the Microsoft documentation for logging. Check your configuration If you are not seeing any logged requests made to IdentityServer, it may be that AdminUI is not pointing at your IdentityServer. To confirm that AdminUI is configured correctly, check the AuthorityUrl setting for both the UI and API are the expected value in any web.config (when using IIS/Windows) and appsettings.json files (when using Linux or Kestrel). If you are using an Azure App Service, this can also be set in the App Service\u2019s configuration section. Check the AdminUI logs If you are not seeing any logged requests made to IdentityServer and the configuration looks correct, the next step is to check the AdminUI (UI website) logs . This will cover any issues with connecting to your IdentityServer, including certificate validation. Support If none of these steps work or you are unsure how to fix the error in the logs, please contact us at support@openiddictcomponents.com, detailing the issue you see, including any error logs.","title":"Unable to contact OpenIddict"},{"location":"Troubleshooting/Unable_to_contact_OpenIddict.html#todo-update","text":"If you experience the error message \u201cUnable to contact IdentityServer\u201d, it means that the AdminUI backend cannot successfully communicate with IdentityServer. To troubleshoot this issue, we recommend working through the following steps.","title":"TODO Update"},{"location":"Troubleshooting/Unable_to_contact_OpenIddict.html#does-the-openid-connect-discovery-document-work","text":"You can verify that your IdentityServer can start-up and access your database by navigating to the OpenID Connect discovery document in your browser, available on the IdentityServer endpoint: https://<your-identity-server>/.well-known/openid-configuration .","title":"Does the OpenID Connect discovery document work?"},{"location":"Troubleshooting/Unable_to_contact_OpenIddict.html#discovery-document-does-not-load","text":"If your discovery document does not load, you may instead see an error page containing details on what went wrong. If you do not see any error details, you will need to check the IdentityServer logs .","title":"Discovery document does not load"},{"location":"Troubleshooting/Unable_to_contact_OpenIddict.html#discovery-document-loads","text":"If your discovery document does load, then the next step is to determine why IdentityServer denied the request.","title":"Discovery document loads"},{"location":"Troubleshooting/Unable_to_contact_OpenIddict.html#check-the-identityserver-logs","text":"Depending on your IdentityServer setup, IdentityServer will be logging failed incoming requests. To enable logging, check out our logging documentation . If you are using your own IdentityServer, we recommend following the Microsoft documentation for logging.","title":"Check the IdentityServer logs"},{"location":"Troubleshooting/Unable_to_contact_OpenIddict.html#check-your-configuration","text":"If you are not seeing any logged requests made to IdentityServer, it may be that AdminUI is not pointing at your IdentityServer. To confirm that AdminUI is configured correctly, check the AuthorityUrl setting for both the UI and API are the expected value in any web.config (when using IIS/Windows) and appsettings.json files (when using Linux or Kestrel). If you are using an Azure App Service, this can also be set in the App Service\u2019s configuration section.","title":"Check your configuration"},{"location":"Troubleshooting/Unable_to_contact_OpenIddict.html#check-the-adminui-logs","text":"If you are not seeing any logged requests made to IdentityServer and the configuration looks correct, the next step is to check the AdminUI (UI website) logs . This will cover any issues with connecting to your IdentityServer, including certificate validation.","title":"Check the AdminUI logs"},{"location":"Troubleshooting/Unable_to_contact_OpenIddict.html#support","text":"If none of these steps work or you are unsure how to fix the error in the logs, please contact us at support@openiddictcomponents.com, detailing the issue you see, including any error logs.","title":"Support"},{"location":"Troubleshooting/Unable_to_load_AdminUI.html","text":"TODO Update If you are unable to see the AdminUI Web page, you can troubleshoot using the below steps. AdminUI only loads a blank page With this blank page, we refer to an empty page with the text \"AdminUI\" on the top left corner. Also, if you open the console, you will see a list of 404 errors on different files. This is the index page, and the console logs are saying it cannot find the UI files that load the SPA (Single Page Application). This happens when AdminUI is not running from the root of the URL. Maybe your AdminUI URI is something like 'https://generalweb/myadminui'. To solve this, you have to update the base path on the index.html of AdminUI. The index.html file is inside the wwwroot folder. Notice we refer to the wwwroot folder inside the AdminUI folder, not the one you might have in a parent folder. Find the following code inside index.html: <base href=\"/\"> Following the example above (https://generalweb/myadminui), you would need to change it as follows: <base href=\"/myadminui/\">","title":"Unable to load AdminUI web page"},{"location":"Troubleshooting/Unable_to_load_AdminUI.html#todo-update","text":"If you are unable to see the AdminUI Web page, you can troubleshoot using the below steps.","title":"TODO Update"},{"location":"Troubleshooting/Unable_to_load_AdminUI.html#adminui-only-loads-a-blank-page","text":"With this blank page, we refer to an empty page with the text \"AdminUI\" on the top left corner. Also, if you open the console, you will see a list of 404 errors on different files. This is the index page, and the console logs are saying it cannot find the UI files that load the SPA (Single Page Application). This happens when AdminUI is not running from the root of the URL. Maybe your AdminUI URI is something like 'https://generalweb/myadminui'. To solve this, you have to update the base path on the index.html of AdminUI. The index.html file is inside the wwwroot folder. Notice we refer to the wwwroot folder inside the AdminUI folder, not the one you might have in a parent folder. Find the following code inside index.html: <base href=\"/\"> Following the example above (https://generalweb/myadminui), you would need to change it as follows: <base href=\"/myadminui/\">","title":"AdminUI only loads a blank page"},{"location":"Troubleshooting/Unable_to_log_in.html","text":"TODO Update If you are unable to login, you can troubleshoot using the below steps Help! I\u2019m stuck in a redirect loop If you are stuck in a redirect loop between AdminUI and IdentityServer, this is because AdminUI does not trust or cannot validate the IdentityServer identity token. A common cause for this is when one or more of the applications are running on HTTP rather than HTTPS. This can cause the browser\u2019s SameSite cookie policy to be enforced and AdminUI\u2019s correlation cookie to be unavailable. This correlation cookie contains security data used to verify incoming requests to AdminUI\u2019s redirect endpoint and validate tokens. If this cookie is not present, AdminUI will redirect the user back to IdentityServer. To solve this, ensure all of your applications are running on HTTPS and can validate one another's TLS certificates. If your applications are all running over HTTPS and you are still experiencing a redirect loop then your web server or reverse proxy could be terminating TLS. You will need to modify your web server or reverse proxy to tell AdminUI what the original request was by using X-Forwarded headers, such as X-Forwarded-For and X-Forwarded-Proto. This will tell AdminUI what the original scheme was (e.g. HTTPS) and the domain (e.g. openiddictcomponents.com). Check out the Microsoft documentation for more information on these headers and how AdminUI supports them here . Another common cause for redirect loops is header size limitations. If your max header length is too small to accommodate the AdminUI session cookie, AdminUI will be unable to authenticate and will enter a redirect loop. To fix this, increase the maximum header size for your AdminUI site. We recommend a value of at least 128KB. Invalid client secret If you see an error page within AdminUI after redirecting from IdentityServer to AdminUI, it may be that AdminUI is using an incorrect client secret. This can be proven by checking the IdentityServer logs for a failed request against the token endpoint. To resolve this, ensure that the AdminUI and API sites have the same value for the AdminUIClientSecret configuration setting. Once these are the same, restart the API website for the IdentityServer configuration to be updated. Invalid redirect URI If you see an error page or an error log within IdentityServer that says the redirect URI is invalid, this means that the client configuration held by IdentityServer does not match your AdminUI instance. To resolve this, ensure that the AdminUI API site has the correct URL for the UiUrl configuration setting. Once this is correct, restart the API website for the IdentityServer configuration to be updated. Invalid client If you see an error page or error log within IdentityServer that says the client is invalid, this means that IdentityServer does not recognize the AdminUI client application. This could be due IdentityServer and AdminUI not using the same database for IdentityServer configuration. To resolve this, ensure that both the AdminUI API and your IdentityServer are using the same connection strings. Support If none of these steps work or you are unsure how to fix the error in the logs, please contact us at support@openiddictcomponents.com, detailing the issue you see, including any error logs.","title":"Unable to log in"},{"location":"Troubleshooting/Unable_to_log_in.html#todo-update","text":"If you are unable to login, you can troubleshoot using the below steps","title":"TODO Update"},{"location":"Troubleshooting/Unable_to_log_in.html#help-im-stuck-in-a-redirect-loop","text":"If you are stuck in a redirect loop between AdminUI and IdentityServer, this is because AdminUI does not trust or cannot validate the IdentityServer identity token. A common cause for this is when one or more of the applications are running on HTTP rather than HTTPS. This can cause the browser\u2019s SameSite cookie policy to be enforced and AdminUI\u2019s correlation cookie to be unavailable. This correlation cookie contains security data used to verify incoming requests to AdminUI\u2019s redirect endpoint and validate tokens. If this cookie is not present, AdminUI will redirect the user back to IdentityServer. To solve this, ensure all of your applications are running on HTTPS and can validate one another's TLS certificates. If your applications are all running over HTTPS and you are still experiencing a redirect loop then your web server or reverse proxy could be terminating TLS. You will need to modify your web server or reverse proxy to tell AdminUI what the original request was by using X-Forwarded headers, such as X-Forwarded-For and X-Forwarded-Proto. This will tell AdminUI what the original scheme was (e.g. HTTPS) and the domain (e.g. openiddictcomponents.com). Check out the Microsoft documentation for more information on these headers and how AdminUI supports them here . Another common cause for redirect loops is header size limitations. If your max header length is too small to accommodate the AdminUI session cookie, AdminUI will be unable to authenticate and will enter a redirect loop. To fix this, increase the maximum header size for your AdminUI site. We recommend a value of at least 128KB.","title":"Help! I\u2019m stuck in a redirect loop"},{"location":"Troubleshooting/Unable_to_log_in.html#invalid-client-secret","text":"If you see an error page within AdminUI after redirecting from IdentityServer to AdminUI, it may be that AdminUI is using an incorrect client secret. This can be proven by checking the IdentityServer logs for a failed request against the token endpoint. To resolve this, ensure that the AdminUI and API sites have the same value for the AdminUIClientSecret configuration setting. Once these are the same, restart the API website for the IdentityServer configuration to be updated.","title":"Invalid client secret"},{"location":"Troubleshooting/Unable_to_log_in.html#invalid-redirect-uri","text":"If you see an error page or an error log within IdentityServer that says the redirect URI is invalid, this means that the client configuration held by IdentityServer does not match your AdminUI instance. To resolve this, ensure that the AdminUI API site has the correct URL for the UiUrl configuration setting. Once this is correct, restart the API website for the IdentityServer configuration to be updated.","title":"Invalid redirect URI"},{"location":"Troubleshooting/Unable_to_log_in.html#invalid-client","text":"If you see an error page or error log within IdentityServer that says the client is invalid, this means that IdentityServer does not recognize the AdminUI client application. This could be due IdentityServer and AdminUI not using the same database for IdentityServer configuration. To resolve this, ensure that both the AdminUI API and your IdentityServer are using the same connection strings.","title":"Invalid client"},{"location":"Troubleshooting/Unable_to_log_in.html#support","text":"If none of these steps work or you are unsure how to fix the error in the logs, please contact us at support@openiddictcomponents.com, detailing the issue you see, including any error logs.","title":"Support"},{"location":"User_settings_endpoints/User_settings.html","text":"TODO Update Scopes To access the user settings endpoints, an access token issued by your IdentityServer implementation with the scope admin_ui_public . This access token must have been issued on behalf of a user and contain a sub claim. Authorization Rules In order to use the user settings endpoints, the requesting user, must be the same as the users being updated. Otherwise, a 403 Forbidden will be returned. This is matched using the sub claim issued within the requesting access token. Read To see what claims a user can edit, and their current values, you can call GET on the /UserSettings/{subject} endpoint. This will return the following json: \"subject\": \"string\", \"claims\": \"type\": \"string\", \"value\": \"string\" Update To update a users claims, you can call PUT on the /UserSettings endpoint. \"subject\": \"string\", \"claims\": \"type\": \"string\", \"value\": \"string\"","title":"User Settings Endpoints"},{"location":"User_settings_endpoints/User_settings.html#todo-update","text":"","title":"TODO Update"},{"location":"User_settings_endpoints/User_settings.html#scopes","text":"To access the user settings endpoints, an access token issued by your IdentityServer implementation with the scope admin_ui_public . This access token must have been issued on behalf of a user and contain a sub claim.","title":"Scopes"},{"location":"User_settings_endpoints/User_settings.html#authorization-rules","text":"In order to use the user settings endpoints, the requesting user, must be the same as the users being updated. Otherwise, a 403 Forbidden will be returned. This is matched using the sub claim issued within the requesting access token.","title":"Authorization Rules"},{"location":"User_settings_endpoints/User_settings.html#read","text":"To see what claims a user can edit, and their current values, you can call GET on the /UserSettings/{subject} endpoint. This will return the following json: \"subject\": \"string\", \"claims\": \"type\": \"string\", \"value\": \"string\"","title":"Read"},{"location":"User_settings_endpoints/User_settings.html#update","text":"To update a users claims, you can call PUT on the /UserSettings endpoint. \"subject\": \"string\", \"claims\": \"type\": \"string\", \"value\": \"string\"","title":"Update"},{"location":"Users/Adding_users.html","text":"TODO Update Adding Users From the Users page, click the \"Add a User\" button User Details Fill out the relevant User Details including: Username Email First Name Last Name Any additional required claims will also need to be entered. User Validation You will not be able to add a new user until the required field validation has passed. Save & Configure Once you have successfully entered all required information, you will be able to choose whether to \"Save\" or \"Save and Configure\" this User. Selecting \"Save\" will take you back to the Users screen, selecting \"Save and Configure\" will take you to the User details configuration screen to edit the user. Success You have now successfully added a user. If successful, you should see a Success notification, or you will be informed of any issues.","title":"Adding Users"},{"location":"Users/Adding_users.html#todo-update","text":"","title":"TODO Update"},{"location":"Users/Adding_users.html#adding-users","text":"From the Users page, click the \"Add a User\" button","title":"Adding Users"},{"location":"Users/Adding_users.html#user-details","text":"Fill out the relevant User Details including: Username Email First Name Last Name Any additional required claims will also need to be entered.","title":"User Details"},{"location":"Users/Adding_users.html#user-validation","text":"You will not be able to add a new user until the required field validation has passed.","title":"User Validation"},{"location":"Users/Adding_users.html#save-configure","text":"Once you have successfully entered all required information, you will be able to choose whether to \"Save\" or \"Save and Configure\" this User. Selecting \"Save\" will take you back to the Users screen, selecting \"Save and Configure\" will take you to the User details configuration screen to edit the user.","title":"Save &amp; Configure"},{"location":"Users/Adding_users.html#success","text":"You have now successfully added a user. If successful, you should see a Success notification, or you will be informed of any issues.","title":"Success"},{"location":"Users/Deleting_Users.html","text":"TODO Update Deleting a user If you choose to delete a user from the User Details page, click the delete button. You should then see a dialogue warning you that you are going to delete the user. At this point you can either cancel, or continue with the delete. Confirmation of Delete If the deletion of a user has been successful, a \"user deleted\" confirmation will appear. Keep in mind that this action does not delete the user from your database, unless you have customized this process using a Custom User Store . Instead, it simply flags the user as deleted.","title":"Deleting Users"},{"location":"Users/Deleting_Users.html#todo-update","text":"","title":"TODO Update"},{"location":"Users/Deleting_Users.html#deleting-a-user","text":"If you choose to delete a user from the User Details page, click the delete button. You should then see a dialogue warning you that you are going to delete the user. At this point you can either cancel, or continue with the delete.","title":"Deleting a user"},{"location":"Users/Deleting_Users.html#confirmation-of-delete","text":"If the deletion of a user has been successful, a \"user deleted\" confirmation will appear. Keep in mind that this action does not delete the user from your database, unless you have customized this process using a Custom User Store . Instead, it simply flags the user as deleted.","title":"Confirmation of Delete"},{"location":"Users/Editing_users.html","text":"TODO Update Editing a User Access the User Details screen by finding the user that you want to edit in the Users page list. This will take you to the User Details screen, where you can edit the required User details. You will notice that there are several key tabs, which we will cover in detail. Details Tab The default tab is the \"Details\" tab, where you will see the User ID, and be able to edit the following elements of a user: Username First name Last name Email Organization Any additional, custom required claims you have created You will also be able to set a user to \"Blocked\" or remove their blocked status and set them to \"Active\" again. Once you have successfully made the edits you require, click Save, and you should then see a success dialogue informing you that your changes have been saved. Roles Tab Clicking on the Roles tab allows you to assign roles to a User. Roles administration is explained in more detail in the Roles section, however, you can assign Roles to a user from the Users dialogue. Using this screen you can assign avaliable roles to this user, select the arrow to move the selected roles from Available to Assigned. To remove roles from a user, select the roles you want to remove and click the arrow to move the role from \"Assigned\" to \"Available\". Additional Details Tab Within the User Details page, clicking on the Additional Details tab enables you to add relevant additional optional user details, known as Claims . Here you can assign and remove claims for a specific user. To add a claim click on the \"Add Claim\" button. This will open a dialog to create a claim. Select a claim type from the drop-down of the full list of User claim types, enter a value, and click add to assign the claim to the user. You should then see a success dialogue informing you that your claim has been added. You can choose to edit or delete any claim. Click the pencil icon to edit the claim, or the delete icon to remove the claim entirely from this user. Editing the claim will turn the field into a writeable text-box that will allow you to change the value of the claim. Applications tab Clicking on the Applications tab in the User Details page enables you to view all Applications that the selected User has given consent to. Select an application to see more details about the application including what scopes the application has access to. From here you can also revoke a users consent.","title":"Editing Users"},{"location":"Users/Editing_users.html#todo-update","text":"","title":"TODO Update"},{"location":"Users/Editing_users.html#editing-a-user","text":"Access the User Details screen by finding the user that you want to edit in the Users page list. This will take you to the User Details screen, where you can edit the required User details. You will notice that there are several key tabs, which we will cover in detail.","title":"Editing a User"},{"location":"Users/Editing_users.html#details-tab","text":"The default tab is the \"Details\" tab, where you will see the User ID, and be able to edit the following elements of a user: Username First name Last name Email Organization Any additional, custom required claims you have created You will also be able to set a user to \"Blocked\" or remove their blocked status and set them to \"Active\" again. Once you have successfully made the edits you require, click Save, and you should then see a success dialogue informing you that your changes have been saved.","title":"Details Tab"},{"location":"Users/Editing_users.html#roles-tab","text":"Clicking on the Roles tab allows you to assign roles to a User. Roles administration is explained in more detail in the Roles section, however, you can assign Roles to a user from the Users dialogue. Using this screen you can assign avaliable roles to this user, select the arrow to move the selected roles from Available to Assigned. To remove roles from a user, select the roles you want to remove and click the arrow to move the role from \"Assigned\" to \"Available\".","title":"Roles Tab"},{"location":"Users/Editing_users.html#additional-details-tab","text":"Within the User Details page, clicking on the Additional Details tab enables you to add relevant additional optional user details, known as Claims . Here you can assign and remove claims for a specific user. To add a claim click on the \"Add Claim\" button. This will open a dialog to create a claim. Select a claim type from the drop-down of the full list of User claim types, enter a value, and click add to assign the claim to the user. You should then see a success dialogue informing you that your claim has been added. You can choose to edit or delete any claim. Click the pencil icon to edit the claim, or the delete icon to remove the claim entirely from this user. Editing the claim will turn the field into a writeable text-box that will allow you to change the value of the claim.","title":"Additional Details Tab"},{"location":"Users/Editing_users.html#applications-tab","text":"Clicking on the Applications tab in the User Details page enables you to view all Applications that the selected User has given consent to. Select an application to see more details about the application including what scopes the application has access to. From here you can also revoke a users consent.","title":"Applications tab"},{"location":"Users/Searching_for_users.html","text":"TODO Update Searching for Users You can find Users in the application in several ways, starting with the Search functionality. Start entering the Username, Full Name, or Email of the user you wish to search for. Options should then appear for users that have a Username, Full Name, or Email that starts with the inputted query: Filters for Users It is also possible to apply filters to the user's list. To reveal these filters, click on the 'Show Filters' button. Using Status Users can be one of 3 statuses Active , Blocked or Deleted On the Users page, it is possible to filter users by their status by clicking the relevant Status button enabling/disabling the filter. Users of a state are shown if the filter has a dark blue background and disabled if the background is no longer present. This will filter out all users that are not of that status type. Using Claims Filters also have the option to enable claim values in the properties to which the search term is applied. However, this may hurt the search performance if you have a large set of users.","title":"Searching for Users"},{"location":"Users/Searching_for_users.html#todo-update","text":"","title":"TODO Update"},{"location":"Users/Searching_for_users.html#searching-for-users","text":"You can find Users in the application in several ways, starting with the Search functionality. Start entering the Username, Full Name, or Email of the user you wish to search for. Options should then appear for users that have a Username, Full Name, or Email that starts with the inputted query:","title":"Searching for Users"},{"location":"Users/Searching_for_users.html#filters-for-users","text":"It is also possible to apply filters to the user's list. To reveal these filters, click on the 'Show Filters' button.","title":"Filters for Users"},{"location":"Users/Searching_for_users.html#using-status","text":"Users can be one of 3 statuses Active , Blocked or Deleted On the Users page, it is possible to filter users by their status by clicking the relevant Status button enabling/disabling the filter. Users of a state are shown if the filter has a dark blue background and disabled if the background is no longer present. This will filter out all users that are not of that status type.","title":"Using Status"},{"location":"Users/Searching_for_users.html#using-claims","text":"Filters also have the option to enable claim values in the properties to which the search term is applied. However, this may hurt the search performance if you have a large set of users.","title":"Using Claims"},{"location":"Users/SessionManagement.html","text":"TODO Update Managing Server Side Sessions with AdminUI Server Side Sessions were a feature brought out in IdentityServer Duende 6.1. This feature allows you to store session state in the database rather than in a cookie. If you want to read more about server side sessions including how to enable them you can read the official duende release article Server side sessions can either be viewed under the \"Users\" section in the navigation or per user when editing a user e.g: On these pages you can: Filter sessions Find all sessions created since a given date Find all sessions expired before a given date Search by Subject Delete Records This just calls delete If you want more fully fledged deletion we offer a webhook so you can call off to an endpoint To view the records you will need any of these permissions: - All - All Read Only - User Manager - User Manager Read Only To delete records you need any of the following permissions: - All - User Manager Deleting a session By default AdminUI will only remove the session from the database. If you want to configure further actions to happen on delete AdminUI provides a Server Side Session webhook that will fire when a session is deleted. You can find out how to implement this feature in our webhooks section How to disable This feature is enabled by default. If you do not intend to use this feature you can disable it by configuring the \"EnableSessionManagement\" feature flag in your settings. To do this please refer to our configuration documentation .","title":"Session Management"},{"location":"Users/SessionManagement.html#todo-update","text":"","title":"TODO Update"},{"location":"Users/SessionManagement.html#managing-server-side-sessions-with-adminui","text":"Server Side Sessions were a feature brought out in IdentityServer Duende 6.1. This feature allows you to store session state in the database rather than in a cookie. If you want to read more about server side sessions including how to enable them you can read the official duende release article Server side sessions can either be viewed under the \"Users\" section in the navigation or per user when editing a user e.g: On these pages you can: Filter sessions Find all sessions created since a given date Find all sessions expired before a given date Search by Subject Delete Records This just calls delete If you want more fully fledged deletion we offer a webhook so you can call off to an endpoint To view the records you will need any of these permissions: - All - All Read Only - User Manager - User Manager Read Only To delete records you need any of the following permissions: - All - User Manager","title":"Managing Server Side Sessions with AdminUI"},{"location":"Users/SessionManagement.html#deleting-a-session","text":"By default AdminUI will only remove the session from the database. If you want to configure further actions to happen on delete AdminUI provides a Server Side Session webhook that will fire when a session is deleted. You can find out how to implement this feature in our webhooks section","title":"Deleting a session"},{"location":"Users/SessionManagement.html#how-to-disable","text":"This feature is enabled by default. If you do not intend to use this feature you can disable it by configuring the \"EnableSessionManagement\" feature flag in your settings. To do this please refer to our configuration documentation .","title":"How to disable"},{"location":"Users/Set_User_Password.html","text":"TODO Update Evaluating AdminUI If you are using a demo license key, when you create a user we give you the ability to set a password for that user. We do this to simplify the creation of users while you are evaluating the product. However, we do not recommend this for production installations . In production When you are using a production key we do not give you the ability to set a password for the user on the Add User screen by default. Our recommendation is to use an email flow for the user to set their own password. You can enable this via a webhook as explained here . However, if, in your situation, you do want to enable the ability for an administrator to set the password for a new user, you can turn on this feature with the AddUserPassword as documented here","title":"Set User Password"},{"location":"Users/Set_User_Password.html#todo-update","text":"","title":"TODO Update"},{"location":"Users/Set_User_Password.html#evaluating-adminui","text":"If you are using a demo license key, when you create a user we give you the ability to set a password for that user. We do this to simplify the creation of users while you are evaluating the product. However, we do not recommend this for production installations .","title":"Evaluating AdminUI"},{"location":"Users/Set_User_Password.html#in-production","text":"When you are using a production key we do not give you the ability to set a password for the user on the Add User screen by default. Our recommendation is to use an email flow for the user to set their own password. You can enable this via a webhook as explained here . However, if, in your situation, you do want to enable the ability for an administrator to set the password for a new user, you can turn on this feature with the AddUserPassword as documented here","title":"In production"},{"location":"Webhooks/webhook_endpoint_configuration.html","text":"TODO Update Configuration You must create an endpoint that is secured and authenticated by your IdentityServer that uses the scope you have selected in the webhook configuration page for authorization. Once you have your endpoint configured, you can enable the webhook and set the config setting with the AdminUI API config with Url for your endpoint. If this field is set then on successful User creation this webhook will be triggered. Endpoint Requirements Password Reset, Reset MFA and User Registration Endpoint Requirements AdminUI expects these endpoints to meet the following requirements: Accept POST Accept JSON Accept an email, username and subjectid in the body Body { \"subjectid\": \"string\" \"email\": \"string\", \"username\": \"string\" } Delete Session Webhook Endpoint Requirements AdminUI expects the delete session endpoint to meet the following requirements: Accept DELETE Accept JSON Accept an sessionId as a route parameter. E.g: https://webhookhost/1234-5678 Response On a successful request a 200 OK response should be returned. Debugging If the call made to the endpoint returns anything other than a success code, if logging is correctly configured, a error will be logged by the API containing the returned status code.","title":"Webhook Endpoint Configuration"},{"location":"Webhooks/webhook_endpoint_configuration.html#todo-update","text":"","title":"TODO Update"},{"location":"Webhooks/webhook_endpoint_configuration.html#configuration","text":"You must create an endpoint that is secured and authenticated by your IdentityServer that uses the scope you have selected in the webhook configuration page for authorization. Once you have your endpoint configured, you can enable the webhook and set the config setting with the AdminUI API config with Url for your endpoint. If this field is set then on successful User creation this webhook will be triggered.","title":"Configuration"},{"location":"Webhooks/webhook_endpoint_configuration.html#endpoint-requirements","text":"","title":"Endpoint Requirements"},{"location":"Webhooks/webhook_endpoint_configuration.html#password-reset-reset-mfa-and-user-registration-endpoint-requirements","text":"AdminUI expects these endpoints to meet the following requirements: Accept POST Accept JSON Accept an email, username and subjectid in the body","title":"Password Reset, Reset MFA and User Registration Endpoint Requirements"},{"location":"Webhooks/webhook_endpoint_configuration.html#body","text":"{ \"subjectid\": \"string\" \"email\": \"string\", \"username\": \"string\" }","title":"Body"},{"location":"Webhooks/webhook_endpoint_configuration.html#delete-session-webhook-endpoint-requirements","text":"AdminUI expects the delete session endpoint to meet the following requirements: Accept DELETE Accept JSON Accept an sessionId as a route parameter. E.g: https://webhookhost/1234-5678","title":"Delete Session Webhook Endpoint Requirements"},{"location":"Webhooks/webhook_endpoint_configuration.html#response","text":"On a successful request a 200 OK response should be returned.","title":"Response"},{"location":"Webhooks/webhook_endpoint_configuration.html#debugging","text":"If the call made to the endpoint returns anything other than a success code, if logging is correctly configured, a error will be logged by the API containing the returned status code.","title":"Debugging"},{"location":"Webhooks/webhooks.html","text":"TODO Update Webhooks AdminUI contains three webhooks to extend AdminUI functionality and integrate it with your IdentityServer and custom Identity needs. These webhooks hold no functionality themselves but call secured endpoints to trigger outside functionality, this could within your IdentityServer instance or a separate API. Password reset webhook - This webhook allows AdminUI to trigger custom password reset logic contained elsewhere. User registration webhook - This webhook will trigger any additional account setup process your security solution might have. Reset mfa webhook - This webhook will trigger custom logic used to reset a user's Multi-Factor Authentication. Delete session webhook - This webhook will trigger when you press the delete button on a session in a session management table Webhook Configuration Page As of AdminUI 5.6, you can manage your webhook configuration within AdminUI. You can manage webhook configuration by navigating to the Webhooks tab in the Settings area of AdminUI. Here you can enable/disable the three webhooks, set the endpoint URLs, and choose the desired protecting scope. Triggering Password Reset and Reset MFA After navigating to a user details page, you will find the two buttons used to trigger either the Password Reset webhook or the Reset MFA webhook . If enabled in the Webhook Configuration page, clicking on the desired button will trigger the webhook. If the webhook has not been enabled in the Webhook Configuration page, clicking on the webhook button will direct you to documentation that will inform you on how to configure the webhook. Triggering User Registration Webhook If account creation succeeds and the User registration webhook has been enabled, then the webhook will trigger. If the user registration webhook has not been enabled user registration will still complete successfully, however the webhook will not be called. The recommended way to use this webhook is to send an email to the user with a link to activate their account and set their initial password. Triggering the Delete Session Webhook If setup this webhook fire when you click the red x on a record in a session management table. Information about this feature can be found earlier in the documentation This webhook will send an HTTP Delete to the url of your choosing, including the Session ID in the path. E.g: https://localhost:5003/4b3c19ac-cce4-47c5-ac0e-eb79da45944b For an example of how to implement this webhook with the default Duende session management implementation see our sample Authorization The webhooks will need to be to secured by your IdentityServer. You can choose a scope per endpoint in the Webhook Configuration page. To ensure your webhooks are secured against public use, they should check for a bearer token, issued by your IdentityServer installation, that contains this scope. The configuration of a webhook endpoint is detailed in the Webhook Endpoint Configuration page Client As of AdminUI 5.6, webhook client creation/deletion is handled for you by AdminUI. On enabling your first webhook, AdminUI will inform you that a client is about to be created. The client will try and use the ClientId and ClientSecret fields within your API configuration. If AdminUI cannot find any values for ClientId or ClientSecret configuration fields, it will use a default clientId ( admin_ui_webhooks ) and a default client secret. You can view the secret's unhashed plaintext value in the ConfigurationEntries table under the webhooks key. The client also uses the client_credentials grant type. Webhook Configuration Migration If you are upgrading AdminUI to a version above 5.6 and you are using webhooks, your webhook configuration will be migrated from your API configuration to the ConfigurationEntries table in your IdentityServer. This will happen during the first run of the API. If you have any values against the webhook URL's in your API config or if you have both a ClientId and ClientSecret , AdminUI will create a client for you to use as a webhook client. The client will use the default admin_ui_webhooks protecting scope.","title":"Webhooks"},{"location":"Webhooks/webhooks.html#todo-update","text":"","title":"TODO Update"},{"location":"Webhooks/webhooks.html#webhooks","text":"AdminUI contains three webhooks to extend AdminUI functionality and integrate it with your IdentityServer and custom Identity needs. These webhooks hold no functionality themselves but call secured endpoints to trigger outside functionality, this could within your IdentityServer instance or a separate API. Password reset webhook - This webhook allows AdminUI to trigger custom password reset logic contained elsewhere. User registration webhook - This webhook will trigger any additional account setup process your security solution might have. Reset mfa webhook - This webhook will trigger custom logic used to reset a user's Multi-Factor Authentication. Delete session webhook - This webhook will trigger when you press the delete button on a session in a session management table","title":"Webhooks"},{"location":"Webhooks/webhooks.html#webhook-configuration-page","text":"As of AdminUI 5.6, you can manage your webhook configuration within AdminUI. You can manage webhook configuration by navigating to the Webhooks tab in the Settings area of AdminUI. Here you can enable/disable the three webhooks, set the endpoint URLs, and choose the desired protecting scope.","title":"Webhook Configuration Page"},{"location":"Webhooks/webhooks.html#triggering-password-reset-and-reset-mfa","text":"After navigating to a user details page, you will find the two buttons used to trigger either the Password Reset webhook or the Reset MFA webhook . If enabled in the Webhook Configuration page, clicking on the desired button will trigger the webhook. If the webhook has not been enabled in the Webhook Configuration page, clicking on the webhook button will direct you to documentation that will inform you on how to configure the webhook.","title":"Triggering Password Reset and Reset MFA"},{"location":"Webhooks/webhooks.html#triggering-user-registration-webhook","text":"If account creation succeeds and the User registration webhook has been enabled, then the webhook will trigger. If the user registration webhook has not been enabled user registration will still complete successfully, however the webhook will not be called. The recommended way to use this webhook is to send an email to the user with a link to activate their account and set their initial password.","title":"Triggering User Registration Webhook"},{"location":"Webhooks/webhooks.html#triggering-the-delete-session-webhook","text":"If setup this webhook fire when you click the red x on a record in a session management table. Information about this feature can be found earlier in the documentation This webhook will send an HTTP Delete to the url of your choosing, including the Session ID in the path. E.g: https://localhost:5003/4b3c19ac-cce4-47c5-ac0e-eb79da45944b For an example of how to implement this webhook with the default Duende session management implementation see our sample","title":"Triggering the Delete Session Webhook"},{"location":"Webhooks/webhooks.html#authorization","text":"The webhooks will need to be to secured by your IdentityServer. You can choose a scope per endpoint in the Webhook Configuration page. To ensure your webhooks are secured against public use, they should check for a bearer token, issued by your IdentityServer installation, that contains this scope. The configuration of a webhook endpoint is detailed in the Webhook Endpoint Configuration page","title":"Authorization"},{"location":"Webhooks/webhooks.html#client","text":"As of AdminUI 5.6, webhook client creation/deletion is handled for you by AdminUI. On enabling your first webhook, AdminUI will inform you that a client is about to be created. The client will try and use the ClientId and ClientSecret fields within your API configuration. If AdminUI cannot find any values for ClientId or ClientSecret configuration fields, it will use a default clientId ( admin_ui_webhooks ) and a default client secret. You can view the secret's unhashed plaintext value in the ConfigurationEntries table under the webhooks key. The client also uses the client_credentials grant type.","title":"Client"},{"location":"Webhooks/webhooks.html#webhook-configuration-migration","text":"If you are upgrading AdminUI to a version above 5.6 and you are using webhooks, your webhook configuration will be migrated from your API configuration to the ConfigurationEntries table in your IdentityServer. This will happen during the first run of the API. If you have any values against the webhook URL's in your API config or if you have both a ClientId and ClientSecret , AdminUI will create a client for you to use as a webhook client. The client will use the default admin_ui_webhooks protecting scope.","title":"Webhook Configuration Migration"}]}